{
  "version": 3,
  "sources": ["../../../../../../../src/material/menu/menu-panel.ts", "../../../../../../../src/material/menu/menu-item.ts", "../../../../../../../src/material/menu/menu-item.html", "../../../../../../../src/material/menu/menu-errors.ts", "../../../../../../../src/material/menu/menu-content.ts", "../../../../../../../src/material/menu/menu-animations.ts", "../../../../../../../src/material/menu/menu.ts", "../../../../../../../src/material/menu/menu.html", "../../../../../../../src/material/menu/menu-trigger.ts", "../../../../../../../src/material/menu/module.ts", "../../../../../../../src/material/menu/menu_public_index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter, TemplateRef, InjectionToken} from '@angular/core';\nimport {MenuPositionX, MenuPositionY} from './menu-positions';\nimport {Direction} from '@angular/cdk/bidi';\nimport {FocusOrigin} from '@angular/cdk/a11y';\nimport {MatMenuContent} from './menu-content';\n\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * @docs-private\n */\nexport const MAT_MENU_PANEL = new InjectionToken<MatMenuPanel>('MAT_MENU_PANEL');\n\n/**\n * Interface for a custom menu panel that can be used with `matMenuTriggerFor`.\n * @docs-private\n */\nexport interface MatMenuPanel<T = any> {\n  xPosition: MenuPositionX;\n  yPosition: MenuPositionY;\n  overlapTrigger: boolean;\n  templateRef: TemplateRef<any>;\n  readonly close: EventEmitter<void | 'click' | 'keydown' | 'tab'>;\n  parentMenu?: MatMenuPanel | undefined;\n  direction?: Direction;\n  focusFirstItem: (origin?: FocusOrigin) => void;\n  resetActiveItem: () => void;\n  setPositionClasses?: (x: MenuPositionX, y: MenuPositionY) => void;\n  setElevation?(depth: number): void;\n  lazyContent?: MatMenuContent;\n  backdropClass?: string;\n  overlayPanelClass?: string | string[];\n  hasBackdrop?: boolean;\n  readonly panelId?: string;\n\n  /**\n   * @deprecated To be removed.\n   * @breaking-change 8.0.0\n   */\n  addItem?: (item: T) => void;\n\n  /**\n   * @deprecated To be removed.\n   * @breaking-change 8.0.0\n   */\n  removeItem?: (item: T) => void;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  OnDestroy,\n  ViewEncapsulation,\n  Inject,\n  Optional,\n  Input,\n  AfterViewInit,\n  ChangeDetectorRef,\n  booleanAttribute,\n} from '@angular/core';\nimport {FocusableOption, FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {Subject} from 'rxjs';\nimport {DOCUMENT} from '@angular/common';\nimport {MatMenuPanel, MAT_MENU_PANEL} from './menu-panel';\n\n/**\n * Single item inside a `mat-menu`. Provides the menu item styling and accessibility treatment.\n */\n@Component({\n  selector: '[mat-menu-item]',\n  exportAs: 'matMenuItem',\n  host: {\n    '[attr.role]': 'role',\n    'class': 'mat-mdc-menu-item mat-mdc-focus-indicator',\n    '[class.mat-mdc-menu-item-highlighted]': '_highlighted',\n    '[class.mat-mdc-menu-item-submenu-trigger]': '_triggersSubmenu',\n    '[attr.tabindex]': '_getTabIndex()',\n    '[attr.aria-disabled]': 'disabled',\n    '[attr.disabled]': 'disabled || null',\n    '(click)': '_checkDisabled($event)',\n    '(mouseenter)': '_handleMouseEnter()',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  templateUrl: 'menu-item.html',\n})\nexport class MatMenuItem implements FocusableOption, AfterViewInit, OnDestroy {\n  /** ARIA role for the menu item. */\n  @Input() role: 'menuitem' | 'menuitemradio' | 'menuitemcheckbox' = 'menuitem';\n\n  /** Whether the menu item is disabled. */\n  @Input({transform: booleanAttribute}) disabled: boolean = false;\n\n  /** Whether ripples are disabled on the menu item. */\n  @Input({transform: booleanAttribute}) disableRipple: boolean = false;\n\n  /** Stream that emits when the menu item is hovered. */\n  readonly _hovered: Subject<MatMenuItem> = new Subject<MatMenuItem>();\n\n  /** Stream that emits when the menu item is focused. */\n  readonly _focused = new Subject<MatMenuItem>();\n\n  /** Whether the menu item is highlighted. */\n  _highlighted: boolean = false;\n\n  /** Whether the menu item acts as a trigger for a sub-menu. */\n  _triggersSubmenu: boolean = false;\n\n  constructor(\n    elementRef: ElementRef<HTMLElement>,\n    document: any,\n    focusMonitor: FocusMonitor,\n    parentMenu: MatMenuPanel<MatMenuItem> | undefined,\n    changeDetectorRef: ChangeDetectorRef,\n  );\n\n  /**\n   * @deprecated `document`, `changeDetectorRef` and `focusMonitor` to become required.\n   * @breaking-change 12.0.0\n   */\n  constructor(\n    elementRef: ElementRef<HTMLElement>,\n    document?: any,\n    focusMonitor?: FocusMonitor,\n    parentMenu?: MatMenuPanel<MatMenuItem>,\n    changeDetectorRef?: ChangeDetectorRef,\n  );\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    @Inject(DOCUMENT) private _document?: any,\n    private _focusMonitor?: FocusMonitor,\n    @Inject(MAT_MENU_PANEL) @Optional() public _parentMenu?: MatMenuPanel<MatMenuItem>,\n    private _changeDetectorRef?: ChangeDetectorRef,\n  ) {\n    _parentMenu?.addItem?.(this);\n  }\n\n  /** Focuses the menu item. */\n  focus(origin?: FocusOrigin, options?: FocusOptions): void {\n    if (this._focusMonitor && origin) {\n      this._focusMonitor.focusVia(this._getHostElement(), origin, options);\n    } else {\n      this._getHostElement().focus(options);\n    }\n\n    this._focused.next(this);\n  }\n\n  ngAfterViewInit() {\n    if (this._focusMonitor) {\n      // Start monitoring the element, so it gets the appropriate focused classes. We want\n      // to show the focus style for menu items only when the focus was not caused by a\n      // mouse or touch interaction.\n      this._focusMonitor.monitor(this._elementRef, false);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this._focusMonitor) {\n      this._focusMonitor.stopMonitoring(this._elementRef);\n    }\n\n    if (this._parentMenu && this._parentMenu.removeItem) {\n      this._parentMenu.removeItem(this);\n    }\n\n    this._hovered.complete();\n    this._focused.complete();\n  }\n\n  /** Used to set the `tabindex`. */\n  _getTabIndex(): string {\n    return this.disabled ? '-1' : '0';\n  }\n\n  /** Returns the host DOM element. */\n  _getHostElement(): HTMLElement {\n    return this._elementRef.nativeElement;\n  }\n\n  /** Prevents the default element actions if it is disabled. */\n  _checkDisabled(event: Event): void {\n    if (this.disabled) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  /** Emits to the hover stream. */\n  _handleMouseEnter() {\n    this._hovered.next(this);\n  }\n\n  /** Gets the label to be used when determining whether the option should be focused. */\n  getLabel(): string {\n    const clone = this._elementRef.nativeElement.cloneNode(true) as HTMLElement;\n    const icons = clone.querySelectorAll('mat-icon, .material-icons');\n\n    // Strip away icons, so they don't show up in the text.\n    for (let i = 0; i < icons.length; i++) {\n      icons[i].remove();\n    }\n\n    return clone.textContent?.trim() || '';\n  }\n\n  _setHighlighted(isHighlighted: boolean) {\n    // We need to mark this for check for the case where the content is coming from a\n    // `matMenuContent` whose change detection tree is at the declaration position,\n    // not the insertion position. See #23175.\n    // @breaking-change 12.0.0 Remove null check for `_changeDetectorRef`.\n    this._highlighted = isHighlighted;\n    this._changeDetectorRef?.markForCheck();\n  }\n\n  _setTriggersSubmenu(triggersSubmenu: boolean) {\n    // @breaking-change 12.0.0 Remove null check for `_changeDetectorRef`.\n    this._triggersSubmenu = triggersSubmenu;\n    this._changeDetectorRef?.markForCheck();\n  }\n\n  _hasFocus(): boolean {\n    return this._document && this._document.activeElement === this._getHostElement();\n  }\n}\n", "<ng-content select=\"mat-icon, [matMenuItemIcon]\"></ng-content>\n<span class=\"mat-mdc-menu-item-text\"><ng-content></ng-content></span>\n<div class=\"mat-mdc-menu-ripple\" matRipple\n     [matRippleDisabled]=\"disableRipple || disabled\"\n     [matRippleTrigger]=\"_getHostElement()\">\n</div>\n\n@if (_triggersSubmenu) {\n     <svg\n       class=\"mat-mdc-menu-submenu-icon\"\n       viewBox=\"0 0 5 10\"\n       focusable=\"false\"\n       aria-hidden=\"true\"><polygon points=\"0,0 5,5 0,10\"/></svg>\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * @docs-private\n */\nexport function throwMatMenuInvalidPositionX() {\n  throw Error(`xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\n\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * @docs-private\n */\nexport function throwMatMenuInvalidPositionY() {\n  throw Error(`yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\n\n/**\n * Throws an exception for the case when a menu is assigned\n * to a trigger that is placed inside the same menu.\n * @docs-private\n */\nexport function throwMatMenuRecursiveError() {\n  throw Error(\n    `matMenuTriggerFor: menu cannot contain its own trigger. Assign a menu that is ` +\n      `not a parent of the trigger or move the trigger outside of the menu.`,\n  );\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DomPortalOutlet, TemplatePortal} from '@angular/cdk/portal';\nimport {DOCUMENT} from '@angular/common';\nimport {\n  ApplicationRef,\n  ChangeDetectorRef,\n  ComponentFactoryResolver,\n  Directive,\n  Inject,\n  InjectionToken,\n  Injector,\n  OnDestroy,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport {Subject} from 'rxjs';\n\n/**\n * Injection token that can be used to reference instances of `MatMenuContent`. It serves\n * as alternative token to the actual `MatMenuContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_MENU_CONTENT = new InjectionToken<MatMenuContent>('MatMenuContent');\n\n/** Menu content that will be rendered lazily once the menu is opened. */\n@Directive({\n  selector: 'ng-template[matMenuContent]',\n  providers: [{provide: MAT_MENU_CONTENT, useExisting: MatMenuContent}],\n})\nexport class MatMenuContent implements OnDestroy {\n  private _portal: TemplatePortal<any>;\n  private _outlet: DomPortalOutlet;\n\n  /** Emits when the menu content has been attached. */\n  readonly _attached = new Subject<void>();\n\n  constructor(\n    template: TemplateRef<any>,\n    componentFactoryResolver: ComponentFactoryResolver,\n    appRef: ApplicationRef,\n    injector: Injector,\n    viewContainerRef: ViewContainerRef,\n    document: any,\n    changeDetectorRef: ChangeDetectorRef,\n  );\n\n  /**\n   * @deprecated `changeDetectorRef` is now a required parameter.\n   * @breaking-change 9.0.0\n   */\n  constructor(\n    template: TemplateRef<any>,\n    componentFactoryResolver: ComponentFactoryResolver,\n    appRef: ApplicationRef,\n    injector: Injector,\n    viewContainerRef: ViewContainerRef,\n    document: any,\n    changeDetectorRef?: ChangeDetectorRef,\n  );\n\n  constructor(\n    private _template: TemplateRef<any>,\n    private _componentFactoryResolver: ComponentFactoryResolver,\n    private _appRef: ApplicationRef,\n    private _injector: Injector,\n    private _viewContainerRef: ViewContainerRef,\n    @Inject(DOCUMENT) private _document: any,\n    private _changeDetectorRef?: ChangeDetectorRef,\n  ) {}\n\n  /**\n   * Attaches the content with a particular context.\n   * @docs-private\n   */\n  attach(context: any = {}) {\n    if (!this._portal) {\n      this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n    }\n\n    this.detach();\n\n    if (!this._outlet) {\n      this._outlet = new DomPortalOutlet(\n        this._document.createElement('div'),\n        this._componentFactoryResolver,\n        this._appRef,\n        this._injector,\n      );\n    }\n\n    const element: HTMLElement = this._template.elementRef.nativeElement;\n\n    // Because we support opening the same menu from different triggers (which in turn have their\n    // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n    // risk it staying attached to a pane that's no longer in the DOM.\n    element.parentNode!.insertBefore(this._outlet.outletElement, element);\n\n    // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu\n    // content via `createEmbeddedView` does not cause the content to be seen as \"dirty\"\n    // by Angular. This causes the `@ContentChildren` for menu items within the menu to\n    // not be updated by Angular. By explicitly marking for check here, we tell Angular that\n    // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.\n    // @breaking-change 9.0.0 Make change detector ref required\n    this._changeDetectorRef?.markForCheck();\n    this._portal.attach(this._outlet, context);\n    this._attached.next();\n  }\n\n  /**\n   * Detaches the content.\n   * @docs-private\n   */\n  detach() {\n    if (this._portal.isAttached) {\n      this._portal.detach();\n    }\n  }\n\n  ngOnDestroy() {\n    if (this._outlet) {\n      this._outlet.dispose();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  trigger,\n  state,\n  style,\n  animate,\n  transition,\n  AnimationTriggerMetadata,\n} from '@angular/animations';\n\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * @docs-private\n */\nexport const matMenuAnimations: {\n  readonly transformMenu: AnimationTriggerMetadata;\n  readonly fadeInItems: AnimationTriggerMetadata;\n} = {\n  /**\n   * This animation controls the menu panel's entry and exit from the page.\n   *\n   * When the menu panel is added to the DOM, it scales in and fades in its border.\n   *\n   * When the menu panel is removed from the DOM, it simply fades out after a brief\n   * delay to display the ripple.\n   */\n  transformMenu: trigger('transformMenu', [\n    state(\n      'void',\n      style({\n        opacity: 0,\n        transform: 'scale(0.8)',\n      }),\n    ),\n    transition(\n      'void => enter',\n      animate(\n        '120ms cubic-bezier(0, 0, 0.2, 1)',\n        style({\n          opacity: 1,\n          transform: 'scale(1)',\n        }),\n      ),\n    ),\n    transition('* => void', animate('100ms 25ms linear', style({opacity: 0}))),\n  ]),\n\n  /**\n   * This animation fades in the background color and content of the menu panel\n   * after its containing element is scaled in.\n   */\n  fadeInItems: trigger('fadeInItems', [\n    // TODO(crisbeto): this is inside the `transformMenu`\n    // now. Remove next time we do breaking changes.\n    state('showing', style({opacity: 1})),\n    transition('void => *', [\n      style({opacity: 0}),\n      animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'),\n    ]),\n  ]),\n};\n\n/**\n * @deprecated\n * @breaking-change 8.0.0\n * @docs-private\n */\nexport const fadeInItems = matMenuAnimations.fadeInItems;\n\n/**\n * @deprecated\n * @breaking-change 8.0.0\n * @docs-private\n */\nexport const transformMenu = matMenuAnimations.transformMenu;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChild,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  TemplateRef,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n  OnInit,\n  ChangeDetectorRef,\n  booleanAttribute,\n} from '@angular/core';\nimport {AnimationEvent} from '@angular/animations';\nimport {FocusKeyManager, FocusOrigin} from '@angular/cdk/a11y';\nimport {Direction} from '@angular/cdk/bidi';\nimport {\n  ESCAPE,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  DOWN_ARROW,\n  UP_ARROW,\n  hasModifierKey,\n} from '@angular/cdk/keycodes';\nimport {merge, Observable, Subject, Subscription} from 'rxjs';\nimport {startWith, switchMap, take} from 'rxjs/operators';\nimport {MatMenuItem} from './menu-item';\nimport {MatMenuPanel, MAT_MENU_PANEL} from './menu-panel';\nimport {MenuPositionX, MenuPositionY} from './menu-positions';\nimport {throwMatMenuInvalidPositionX, throwMatMenuInvalidPositionY} from './menu-errors';\nimport {MatMenuContent, MAT_MENU_CONTENT} from './menu-content';\nimport {matMenuAnimations} from './menu-animations';\n\nlet menuPanelUid = 0;\n\n/** Reason why the menu was closed. */\nexport type MenuCloseReason = void | 'click' | 'keydown' | 'tab';\n\n/** Default `mat-menu` options that can be overridden. */\nexport interface MatMenuDefaultOptions {\n  /** The x-axis position of the menu. */\n  xPosition: MenuPositionX;\n\n  /** The y-axis position of the menu. */\n  yPosition: MenuPositionY;\n\n  /** Whether the menu should overlap the menu trigger. */\n  overlapTrigger: boolean;\n\n  /** Class to be applied to the menu's backdrop. */\n  backdropClass: string;\n\n  /** Class or list of classes to be applied to the menu's overlay panel. */\n  overlayPanelClass?: string | string[];\n\n  /** Whether the menu has a backdrop. */\n  hasBackdrop?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mat-menu`. */\nexport const MAT_MENU_DEFAULT_OPTIONS = new InjectionToken<MatMenuDefaultOptions>(\n  'mat-menu-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\n/** @docs-private */\nexport function MAT_MENU_DEFAULT_OPTIONS_FACTORY(): MatMenuDefaultOptions {\n  return {\n    overlapTrigger: false,\n    xPosition: 'after',\n    yPosition: 'below',\n    backdropClass: 'cdk-overlay-transparent-backdrop',\n  };\n}\n\n@Component({\n  selector: 'mat-menu',\n  templateUrl: 'menu.html',\n  styleUrls: ['menu.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  exportAs: 'matMenu',\n  host: {\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    'ngSkipHydration': '',\n  },\n  animations: [matMenuAnimations.transformMenu, matMenuAnimations.fadeInItems],\n  providers: [{provide: MAT_MENU_PANEL, useExisting: MatMenu}],\n})\nexport class MatMenu implements AfterContentInit, MatMenuPanel<MatMenuItem>, OnInit, OnDestroy {\n  private _keyManager: FocusKeyManager<MatMenuItem>;\n  private _xPosition: MenuPositionX;\n  private _yPosition: MenuPositionY;\n  private _firstItemFocusSubscription?: Subscription;\n  private _previousElevation: string;\n  private _elevationPrefix = 'mat-elevation-z';\n  private _baseElevation = 8;\n\n  /** All items inside the menu. Includes items nested inside another menu. */\n  @ContentChildren(MatMenuItem, {descendants: true}) _allItems: QueryList<MatMenuItem>;\n\n  /** Only the direct descendant menu items. */\n  _directDescendantItems = new QueryList<MatMenuItem>();\n\n  /** Config object to be passed into the menu's ngClass */\n  _classList: {[key: string]: boolean} = {};\n\n  /** Current state of the panel animation. */\n  _panelAnimationState: 'void' | 'enter' = 'void';\n\n  /** Emits whenever an animation on the menu completes. */\n  readonly _animationDone = new Subject<AnimationEvent>();\n\n  /** Whether the menu is animating. */\n  _isAnimating: boolean;\n\n  /** Parent menu of the current menu panel. */\n  parentMenu: MatMenuPanel | undefined;\n\n  /** Layout direction of the menu. */\n  direction: Direction;\n\n  /** Class or list of classes to be added to the overlay panel. */\n  overlayPanelClass: string | string[];\n\n  /** Class to be added to the backdrop element. */\n  @Input() backdropClass: string;\n\n  /** aria-label for the menu panel. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** aria-labelledby for the menu panel. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** aria-describedby for the menu panel. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Position of the menu in the X axis. */\n  @Input()\n  get xPosition(): MenuPositionX {\n    return this._xPosition;\n  }\n  set xPosition(value: MenuPositionX) {\n    if (\n      value !== 'before' &&\n      value !== 'after' &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throwMatMenuInvalidPositionX();\n    }\n    this._xPosition = value;\n    this.setPositionClasses();\n  }\n\n  /** Position of the menu in the Y axis. */\n  @Input()\n  get yPosition(): MenuPositionY {\n    return this._yPosition;\n  }\n  set yPosition(value: MenuPositionY) {\n    if (value !== 'above' && value !== 'below' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwMatMenuInvalidPositionY();\n    }\n    this._yPosition = value;\n    this.setPositionClasses();\n  }\n\n  /** @docs-private */\n  @ViewChild(TemplateRef) templateRef: TemplateRef<any>;\n\n  /**\n   * List of the items inside of a menu.\n   * @deprecated\n   * @breaking-change 8.0.0\n   */\n  @ContentChildren(MatMenuItem, {descendants: false}) items: QueryList<MatMenuItem>;\n\n  /**\n   * Menu content that will be rendered lazily.\n   * @docs-private\n   */\n  @ContentChild(MAT_MENU_CONTENT) lazyContent: MatMenuContent;\n\n  /** Whether the menu should overlap its trigger. */\n  @Input({transform: booleanAttribute}) overlapTrigger: boolean;\n\n  /** Whether the menu has a backdrop. */\n  @Input({transform: (value: any) => (value == null ? null : booleanAttribute(value))})\n  hasBackdrop?: boolean;\n\n  /**\n   * This method takes classes set on the host mat-menu element and applies them on the\n   * menu template that displays in the overlay container.  Otherwise, it's difficult\n   * to style the containing menu from outside the component.\n   * @param classes list of class names\n   */\n  @Input('class')\n  set panelClass(classes: string) {\n    const previousPanelClass = this._previousPanelClass;\n\n    if (previousPanelClass && previousPanelClass.length) {\n      previousPanelClass.split(' ').forEach((className: string) => {\n        this._classList[className] = false;\n      });\n    }\n\n    this._previousPanelClass = classes;\n\n    if (classes && classes.length) {\n      classes.split(' ').forEach((className: string) => {\n        this._classList[className] = true;\n      });\n\n      this._elementRef.nativeElement.className = '';\n    }\n  }\n  private _previousPanelClass: string;\n\n  /**\n   * This method takes classes set on the host mat-menu element and applies them on the\n   * menu template that displays in the overlay container.  Otherwise, it's difficult\n   * to style the containing menu from outside the component.\n   * @deprecated Use `panelClass` instead.\n   * @breaking-change 8.0.0\n   */\n  @Input()\n  get classList(): string {\n    return this.panelClass;\n  }\n  set classList(classes: string) {\n    this.panelClass = classes;\n  }\n\n  /** Event emitted when the menu is closed. */\n  @Output() readonly closed: EventEmitter<MenuCloseReason> = new EventEmitter<MenuCloseReason>();\n\n  /**\n   * Event emitted when the menu is closed.\n   * @deprecated Switch to `closed` instead\n   * @breaking-change 8.0.0\n   */\n  @Output() readonly close: EventEmitter<MenuCloseReason> = this.closed;\n\n  readonly panelId = `mat-menu-panel-${menuPanelUid++}`;\n\n  constructor(\n    elementRef: ElementRef<HTMLElement>,\n    ngZone: NgZone,\n    defaultOptions: MatMenuDefaultOptions,\n    changeDetectorRef: ChangeDetectorRef,\n  );\n\n  /**\n   * @deprecated `_changeDetectorRef` to become a required parameter.\n   * @breaking-change 15.0.0\n   */\n  constructor(\n    elementRef: ElementRef<HTMLElement>,\n    ngZone: NgZone,\n    defaultOptions: MatMenuDefaultOptions,\n    changeDetectorRef?: ChangeDetectorRef,\n  );\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _ngZone: NgZone,\n    @Inject(MAT_MENU_DEFAULT_OPTIONS) defaultOptions: MatMenuDefaultOptions,\n    // @breaking-change 15.0.0 `_changeDetectorRef` to become a required parameter.\n    private _changeDetectorRef?: ChangeDetectorRef,\n  ) {\n    this.overlayPanelClass = defaultOptions.overlayPanelClass || '';\n    this._xPosition = defaultOptions.xPosition;\n    this._yPosition = defaultOptions.yPosition;\n    this.backdropClass = defaultOptions.backdropClass;\n    this.overlapTrigger = defaultOptions.overlapTrigger;\n    this.hasBackdrop = defaultOptions.hasBackdrop;\n  }\n\n  ngOnInit() {\n    this.setPositionClasses();\n  }\n\n  ngAfterContentInit() {\n    this._updateDirectDescendants();\n    this._keyManager = new FocusKeyManager(this._directDescendantItems)\n      .withWrap()\n      .withTypeAhead()\n      .withHomeAndEnd();\n    this._keyManager.tabOut.subscribe(() => this.closed.emit('tab'));\n\n    // If a user manually (programmatically) focuses a menu item, we need to reflect that focus\n    // change back to the key manager. Note that we don't need to unsubscribe here because _focused\n    // is internal and we know that it gets completed on destroy.\n    this._directDescendantItems.changes\n      .pipe(\n        startWith(this._directDescendantItems),\n        switchMap(items => merge(...items.map((item: MatMenuItem) => item._focused))),\n      )\n      .subscribe(focusedItem => this._keyManager.updateActiveItem(focusedItem as MatMenuItem));\n\n    this._directDescendantItems.changes.subscribe((itemsList: QueryList<MatMenuItem>) => {\n      // Move focus to another item, if the active item is removed from the list.\n      // We need to debounce the callback, because multiple items might be removed\n      // in quick succession.\n      const manager = this._keyManager;\n\n      if (this._panelAnimationState === 'enter' && manager.activeItem?._hasFocus()) {\n        const items = itemsList.toArray();\n        const index = Math.max(0, Math.min(items.length - 1, manager.activeItemIndex || 0));\n\n        if (items[index] && !items[index].disabled) {\n          manager.setActiveItem(index);\n        } else {\n          manager.setNextItemActive();\n        }\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._keyManager?.destroy();\n    this._directDescendantItems.destroy();\n    this.closed.complete();\n    this._firstItemFocusSubscription?.unsubscribe();\n  }\n\n  /** Stream that emits whenever the hovered menu item changes. */\n  _hovered(): Observable<MatMenuItem> {\n    // Coerce the `changes` property because Angular types it as `Observable<any>`\n    const itemChanges = this._directDescendantItems.changes as Observable<QueryList<MatMenuItem>>;\n    return itemChanges.pipe(\n      startWith(this._directDescendantItems),\n      switchMap(items => merge(...items.map((item: MatMenuItem) => item._hovered))),\n    ) as Observable<MatMenuItem>;\n  }\n\n  /*\n   * Registers a menu item with the menu.\n   * @docs-private\n   * @deprecated No longer being used. To be removed.\n   * @breaking-change 9.0.0\n   */\n  addItem(_item: MatMenuItem) {}\n\n  /**\n   * Removes an item from the menu.\n   * @docs-private\n   * @deprecated No longer being used. To be removed.\n   * @breaking-change 9.0.0\n   */\n  removeItem(_item: MatMenuItem) {}\n\n  /** Handle a keyboard event from the menu, delegating to the appropriate action. */\n  _handleKeydown(event: KeyboardEvent) {\n    const keyCode = event.keyCode;\n    const manager = this._keyManager;\n\n    switch (keyCode) {\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          this.closed.emit('keydown');\n        }\n        break;\n      case LEFT_ARROW:\n        if (this.parentMenu && this.direction === 'ltr') {\n          this.closed.emit('keydown');\n        }\n        break;\n      case RIGHT_ARROW:\n        if (this.parentMenu && this.direction === 'rtl') {\n          this.closed.emit('keydown');\n        }\n        break;\n      default:\n        if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n          manager.setFocusOrigin('keyboard');\n        }\n\n        manager.onKeydown(event);\n        return;\n    }\n\n    // Don't allow the event to propagate if we've already handled it, or it may\n    // end up reaching other overlays that were opened earlier (see #22694).\n    event.stopPropagation();\n  }\n\n  /**\n   * Focus the first item in the menu.\n   * @param origin Action from which the focus originated. Used to set the correct styling.\n   */\n  focusFirstItem(origin: FocusOrigin = 'program'): void {\n    // Wait for `onStable` to ensure iOS VoiceOver screen reader focuses the first item (#24735).\n    this._firstItemFocusSubscription?.unsubscribe();\n    this._firstItemFocusSubscription = this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n      let menuPanel: HTMLElement | null = null;\n\n      if (this._directDescendantItems.length) {\n        // Because the `mat-menuPanel` is at the DOM insertion point, not inside the overlay, we don't\n        // have a nice way of getting a hold of the menuPanel panel. We can't use a `ViewChild` either\n        // because the panel is inside an `ng-template`. We work around it by starting from one of\n        // the items and walking up the DOM.\n        menuPanel = this._directDescendantItems.first!._getHostElement().closest('[role=\"menu\"]');\n      }\n\n      // If an item in the menuPanel is already focused, avoid overriding the focus.\n      if (!menuPanel || !menuPanel.contains(document.activeElement)) {\n        const manager = this._keyManager;\n        manager.setFocusOrigin(origin).setFirstItemActive();\n\n        // If there's no active item at this point, it means that all the items are disabled.\n        // Move focus to the menuPanel panel so keyboard events like Escape still work. Also this will\n        // give _some_ feedback to screen readers.\n        if (!manager.activeItem && menuPanel) {\n          menuPanel.focus();\n        }\n      }\n    });\n  }\n\n  /**\n   * Resets the active item in the menu. This is used when the menu is opened, allowing\n   * the user to start from the first option when pressing the down arrow.\n   */\n  resetActiveItem() {\n    this._keyManager.setActiveItem(-1);\n  }\n\n  /**\n   * Sets the menu panel elevation.\n   * @param depth Number of parent menus that come before the menu.\n   */\n  setElevation(depth: number): void {\n    // The elevation starts at the base and increases by one for each level.\n    // Capped at 24 because that's the maximum elevation defined in the Material design spec.\n    const elevation = Math.min(this._baseElevation + depth, 24);\n    const newElevation = `${this._elevationPrefix}${elevation}`;\n    const customElevation = Object.keys(this._classList).find(className => {\n      return className.startsWith(this._elevationPrefix);\n    });\n\n    if (!customElevation || customElevation === this._previousElevation) {\n      if (this._previousElevation) {\n        this._classList[this._previousElevation] = false;\n      }\n\n      this._classList[newElevation] = true;\n      this._previousElevation = newElevation;\n    }\n  }\n\n  /**\n   * Adds classes to the menu panel based on its position. Can be used by\n   * consumers to add specific styling based on the position.\n   * @param posX Position of the menu along the x axis.\n   * @param posY Position of the menu along the y axis.\n   * @docs-private\n   */\n  setPositionClasses(posX: MenuPositionX = this.xPosition, posY: MenuPositionY = this.yPosition) {\n    const classes = this._classList;\n    classes['mat-menu-before'] = posX === 'before';\n    classes['mat-menu-after'] = posX === 'after';\n    classes['mat-menu-above'] = posY === 'above';\n    classes['mat-menu-below'] = posY === 'below';\n\n    // @breaking-change 15.0.0 Remove null check for `_changeDetectorRef`.\n    this._changeDetectorRef?.markForCheck();\n  }\n\n  /** Starts the enter animation. */\n  _startAnimation() {\n    // @breaking-change 8.0.0 Combine with _resetAnimation.\n    this._panelAnimationState = 'enter';\n  }\n\n  /** Resets the panel animation to its initial state. */\n  _resetAnimation() {\n    // @breaking-change 8.0.0 Combine with _startAnimation.\n    this._panelAnimationState = 'void';\n  }\n\n  /** Callback that is invoked when the panel animation completes. */\n  _onAnimationDone(event: AnimationEvent) {\n    this._animationDone.next(event);\n    this._isAnimating = false;\n  }\n\n  _onAnimationStart(event: AnimationEvent) {\n    this._isAnimating = true;\n\n    // Scroll the content element to the top as soon as the animation starts. This is necessary,\n    // because we move focus to the first item while it's still being animated, which can throw\n    // the browser off when it determines the scroll position. Alternatively we can move focus\n    // when the animation is done, however moving focus asynchronously will interrupt screen\n    // readers which are in the process of reading out the menu already. We take the `element`\n    // from the `event` since we can't use a `ViewChild` to access the pane.\n    if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n      event.element.scrollTop = 0;\n    }\n  }\n\n  /**\n   * Sets up a stream that will keep track of any newly-added menu items and will update the list\n   * of direct descendants. We collect the descendants this way, because `_allItems` can include\n   * items that are part of child menus, and using a custom way of registering items is unreliable\n   * when it comes to maintaining the item order.\n   */\n  private _updateDirectDescendants() {\n    this._allItems.changes\n      .pipe(startWith(this._allItems))\n      .subscribe((items: QueryList<MatMenuItem>) => {\n        this._directDescendantItems.reset(items.filter(item => item._parentMenu === this));\n        this._directDescendantItems.notifyOnChanges();\n      });\n  }\n}\n", "<ng-template>\n  <div\n    class=\"mat-mdc-menu-panel mat-mdc-elevation-specific\"\n    [id]=\"panelId\"\n    [ngClass]=\"_classList\"\n    (keydown)=\"_handleKeydown($event)\"\n    (click)=\"closed.emit('click')\"\n    [@transformMenu]=\"_panelAnimationState\"\n    (@transformMenu.start)=\"_onAnimationStart($event)\"\n    (@transformMenu.done)=\"_onAnimationDone($event)\"\n    tabindex=\"-1\"\n    role=\"menu\"\n    [attr.aria-label]=\"ariaLabel || null\"\n    [attr.aria-labelledby]=\"ariaLabelledby || null\"\n    [attr.aria-describedby]=\"ariaDescribedby || null\">\n    <div class=\"mat-mdc-menu-content\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  FocusMonitor,\n  FocusOrigin,\n  isFakeMousedownFromScreenReader,\n  isFakeTouchstartFromScreenReader,\n} from '@angular/cdk/a11y';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {ENTER, LEFT_ARROW, RIGHT_ARROW, SPACE} from '@angular/cdk/keycodes';\nimport {\n  FlexibleConnectedPositionStrategy,\n  HorizontalConnectionPos,\n  Overlay,\n  OverlayConfig,\n  OverlayRef,\n  ScrollStrategy,\n  VerticalConnectionPos,\n} from '@angular/cdk/overlay';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {\n  AfterContentInit,\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  inject,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  Self,\n  ViewContainerRef,\n} from '@angular/core';\nimport {normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {asapScheduler, merge, Observable, of as observableOf, Subscription} from 'rxjs';\nimport {delay, filter, take, takeUntil} from 'rxjs/operators';\nimport {MatMenu, MenuCloseReason} from './menu';\nimport {throwMatMenuRecursiveError} from './menu-errors';\nimport {MatMenuItem} from './menu-item';\nimport {MAT_MENU_PANEL, MatMenuPanel} from './menu-panel';\nimport {MenuPositionX, MenuPositionY} from './menu-positions';\n\n/** Injection token that determines the scroll handling while the menu is open. */\nexport const MAT_MENU_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-menu-scroll-strategy',\n);\n\n/** @docs-private */\nexport function MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.reposition();\n}\n\n/** @docs-private */\nexport const MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_MENU_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\n};\n\n/** Options for binding a passive event listener. */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({passive: true});\n\n/**\n * Default top padding of the menu panel.\n * @deprecated No longer being used. Will be removed.\n * @breaking-change 15.0.0\n */\nexport const MENU_PANEL_TOP_PADDING = 8;\n\n/** Directive applied to an element that should trigger a `mat-menu`. */\n@Directive({\n  selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,\n  host: {\n    'class': 'mat-mdc-menu-trigger',\n    '[attr.aria-haspopup]': 'menu ? \"menu\" : null',\n    '[attr.aria-expanded]': 'menuOpen',\n    '[attr.aria-controls]': 'menuOpen ? menu.panelId : null',\n    '(click)': '_handleClick($event)',\n    '(mousedown)': '_handleMousedown($event)',\n    '(keydown)': '_handleKeydown($event)',\n  },\n  exportAs: 'matMenuTrigger',\n})\nexport class MatMenuTrigger implements AfterContentInit, OnDestroy {\n  private _portal: TemplatePortal;\n  private _overlayRef: OverlayRef | null = null;\n  private _menuOpen: boolean = false;\n  private _closingActionsSubscription = Subscription.EMPTY;\n  private _hoverSubscription = Subscription.EMPTY;\n  private _menuCloseSubscription = Subscription.EMPTY;\n  private _scrollStrategy: () => ScrollStrategy;\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n\n  /**\n   * We're specifically looking for a `MatMenu` here since the generic `MatMenuPanel`\n   * interface lacks some functionality around nested menus and animations.\n   */\n  private _parentMaterialMenu: MatMenu | undefined;\n\n  /**\n   * Cached value of the padding of the parent menu panel.\n   * Used to offset sub-menus to compensate for the padding.\n   */\n  private _parentInnerPadding: number | undefined;\n\n  /**\n   * Handles touch start events on the trigger.\n   * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\n   */\n  private _handleTouchStart = (event: TouchEvent) => {\n    if (!isFakeTouchstartFromScreenReader(event)) {\n      this._openedBy = 'touch';\n    }\n  };\n\n  // Tracking input type is necessary so it's possible to only auto-focus\n  // the first item of the list when the menu is opened via the keyboard\n  _openedBy: Exclude<FocusOrigin, 'program' | null> | undefined = undefined;\n\n  /**\n   * @deprecated\n   * @breaking-change 8.0.0\n   */\n  @Input('mat-menu-trigger-for')\n  get _deprecatedMatMenuTriggerFor(): MatMenuPanel | null {\n    return this.menu;\n  }\n  set _deprecatedMatMenuTriggerFor(v: MatMenuPanel | null) {\n    this.menu = v;\n  }\n\n  /** References the menu instance that the trigger is associated with. */\n  @Input('matMenuTriggerFor')\n  get menu(): MatMenuPanel | null {\n    return this._menu;\n  }\n  set menu(menu: MatMenuPanel | null) {\n    if (menu === this._menu) {\n      return;\n    }\n\n    this._menu = menu;\n    this._menuCloseSubscription.unsubscribe();\n\n    if (menu) {\n      if (menu === this._parentMaterialMenu && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throwMatMenuRecursiveError();\n      }\n\n      this._menuCloseSubscription = menu.close.subscribe((reason: MenuCloseReason) => {\n        this._destroyMenu(reason);\n\n        // If a click closed the menu, we should close the entire chain of nested menus.\n        if ((reason === 'click' || reason === 'tab') && this._parentMaterialMenu) {\n          this._parentMaterialMenu.closed.emit(reason);\n        }\n      });\n    }\n\n    this._menuItemInstance?._setTriggersSubmenu(this.triggersSubmenu());\n  }\n  private _menu: MatMenuPanel | null;\n\n  /** Data to be passed along to any lazily-rendered content. */\n  @Input('matMenuTriggerData') menuData: any;\n\n  /**\n   * Whether focus should be restored when the menu is closed.\n   * Note that disabling this option can have accessibility implications\n   * and it's up to you to manage focus, if you decide to turn it off.\n   */\n  @Input('matMenuTriggerRestoreFocus') restoreFocus: boolean = true;\n\n  /** Event emitted when the associated menu is opened. */\n  @Output() readonly menuOpened: EventEmitter<void> = new EventEmitter<void>();\n\n  /**\n   * Event emitted when the associated menu is opened.\n   * @deprecated Switch to `menuOpened` instead\n   * @breaking-change 8.0.0\n   */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() readonly onMenuOpen: EventEmitter<void> = this.menuOpened;\n\n  /** Event emitted when the associated menu is closed. */\n  @Output() readonly menuClosed: EventEmitter<void> = new EventEmitter<void>();\n\n  /**\n   * Event emitted when the associated menu is closed.\n   * @deprecated Switch to `menuClosed` instead\n   * @breaking-change 8.0.0\n   */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() readonly onMenuClose: EventEmitter<void> = this.menuClosed;\n\n  constructor(\n    overlay: Overlay,\n    element: ElementRef<HTMLElement>,\n    viewContainerRef: ViewContainerRef,\n    scrollStrategy: any,\n    parentMenu: MatMenuPanel,\n    menuItemInstance: MatMenuItem,\n    dir: Directionality,\n    focusMonitor: FocusMonitor,\n    ngZone: NgZone,\n  );\n\n  /**\n   * @deprecated `focusMonitor` will become a required parameter.\n   * @breaking-change 8.0.0\n   */\n  constructor(\n    overlay: Overlay,\n    element: ElementRef<HTMLElement>,\n    viewContainerRef: ViewContainerRef,\n    scrollStrategy: any,\n    parentMenu: MatMenuPanel,\n    menuItemInstance: MatMenuItem,\n    dir: Directionality,\n    focusMonitor?: FocusMonitor | null,\n  );\n\n  /**\n   * @deprecated `ngZone` will become a required parameter.\n   * @breaking-change 15.0.0\n   */\n  constructor(\n    overlay: Overlay,\n    element: ElementRef<HTMLElement>,\n    viewContainerRef: ViewContainerRef,\n    scrollStrategy: any,\n    parentMenu: MatMenuPanel,\n    menuItemInstance: MatMenuItem,\n    dir: Directionality,\n    focusMonitor: FocusMonitor,\n  );\n\n  constructor(\n    private _overlay: Overlay,\n    private _element: ElementRef<HTMLElement>,\n    private _viewContainerRef: ViewContainerRef,\n    @Inject(MAT_MENU_SCROLL_STRATEGY) scrollStrategy: any,\n    @Inject(MAT_MENU_PANEL) @Optional() parentMenu: MatMenuPanel,\n    // `MatMenuTrigger` is commonly used in combination with a `MatMenuItem`.\n    // tslint:disable-next-line: lightweight-tokens\n    @Optional() @Self() private _menuItemInstance: MatMenuItem,\n    @Optional() private _dir: Directionality,\n    private _focusMonitor: FocusMonitor | null,\n    private _ngZone?: NgZone,\n  ) {\n    this._scrollStrategy = scrollStrategy;\n    this._parentMaterialMenu = parentMenu instanceof MatMenu ? parentMenu : undefined;\n\n    _element.nativeElement.addEventListener(\n      'touchstart',\n      this._handleTouchStart,\n      passiveEventListenerOptions,\n    );\n  }\n\n  ngAfterContentInit() {\n    this._handleHover();\n  }\n\n  ngOnDestroy() {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n\n    this._element.nativeElement.removeEventListener(\n      'touchstart',\n      this._handleTouchStart,\n      passiveEventListenerOptions,\n    );\n\n    this._menuCloseSubscription.unsubscribe();\n    this._closingActionsSubscription.unsubscribe();\n    this._hoverSubscription.unsubscribe();\n  }\n\n  /** Whether the menu is open. */\n  get menuOpen(): boolean {\n    return this._menuOpen;\n  }\n\n  /** The text direction of the containing app. */\n  get dir(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Whether the menu triggers a sub-menu or a top-level one. */\n  triggersSubmenu(): boolean {\n    return !!(this._menuItemInstance && this._parentMaterialMenu && this.menu);\n  }\n\n  /** Toggles the menu between the open and closed states. */\n  toggleMenu(): void {\n    return this._menuOpen ? this.closeMenu() : this.openMenu();\n  }\n\n  /** Opens the menu. */\n  openMenu(): void {\n    const menu = this.menu;\n\n    if (this._menuOpen || !menu) {\n      return;\n    }\n\n    const overlayRef = this._createOverlay(menu);\n    const overlayConfig = overlayRef.getConfig();\n    const positionStrategy = overlayConfig.positionStrategy as FlexibleConnectedPositionStrategy;\n\n    this._setPosition(menu, positionStrategy);\n    overlayConfig.hasBackdrop =\n      menu.hasBackdrop == null ? !this.triggersSubmenu() : menu.hasBackdrop;\n    overlayRef.attach(this._getPortal(menu));\n\n    if (menu.lazyContent) {\n      menu.lazyContent.attach(this.menuData);\n    }\n\n    this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu());\n    this._initMenu(menu);\n\n    if (menu instanceof MatMenu) {\n      menu._startAnimation();\n      menu._directDescendantItems.changes.pipe(takeUntil(menu.close)).subscribe(() => {\n        // Re-adjust the position without locking when the amount of items\n        // changes so that the overlay is allowed to pick a new optimal position.\n        positionStrategy.withLockedPosition(false).reapplyLastPosition();\n        positionStrategy.withLockedPosition(true);\n      });\n    }\n  }\n\n  /** Closes the menu. */\n  closeMenu(): void {\n    this.menu?.close.emit();\n  }\n\n  /**\n   * Focuses the menu trigger.\n   * @param origin Source of the menu trigger's focus.\n   */\n  focus(origin?: FocusOrigin, options?: FocusOptions) {\n    if (this._focusMonitor && origin) {\n      this._focusMonitor.focusVia(this._element, origin, options);\n    } else {\n      this._element.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Updates the position of the menu to ensure that it fits all options within the viewport.\n   */\n  updatePosition(): void {\n    this._overlayRef?.updatePosition();\n  }\n\n  /** Closes the menu and does the necessary cleanup. */\n  private _destroyMenu(reason: MenuCloseReason) {\n    if (!this._overlayRef || !this.menuOpen) {\n      return;\n    }\n\n    const menu = this.menu;\n    this._closingActionsSubscription.unsubscribe();\n    this._overlayRef.detach();\n\n    // Always restore focus if the user is navigating using the keyboard or the menu was opened\n    // programmatically. We don't restore for non-root triggers, because it can prevent focus\n    // from making it back to the root trigger when closing a long chain of menus by clicking\n    // on the backdrop.\n    if (this.restoreFocus && (reason === 'keydown' || !this._openedBy || !this.triggersSubmenu())) {\n      this.focus(this._openedBy);\n    }\n\n    this._openedBy = undefined;\n\n    if (menu instanceof MatMenu) {\n      menu._resetAnimation();\n\n      if (menu.lazyContent) {\n        // Wait for the exit animation to finish before detaching the content.\n        menu._animationDone\n          .pipe(\n            filter(event => event.toState === 'void'),\n            take(1),\n            // Interrupt if the content got re-attached.\n            takeUntil(menu.lazyContent._attached),\n          )\n          .subscribe({\n            next: () => menu.lazyContent!.detach(),\n            // No matter whether the content got re-attached, reset the menu.\n            complete: () => this._setIsMenuOpen(false),\n          });\n      } else {\n        this._setIsMenuOpen(false);\n      }\n    } else {\n      this._setIsMenuOpen(false);\n      menu?.lazyContent?.detach();\n    }\n  }\n\n  /**\n   * This method sets the menu state to open and focuses the first item if\n   * the menu was opened via the keyboard.\n   */\n  private _initMenu(menu: MatMenuPanel): void {\n    menu.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : undefined;\n    menu.direction = this.dir;\n    this._setMenuElevation(menu);\n    menu.focusFirstItem(this._openedBy || 'program');\n    this._setIsMenuOpen(true);\n  }\n\n  /** Updates the menu elevation based on the amount of parent menus that it has. */\n  private _setMenuElevation(menu: MatMenuPanel): void {\n    if (menu.setElevation) {\n      let depth = 0;\n      let parentMenu = menu.parentMenu;\n\n      while (parentMenu) {\n        depth++;\n        parentMenu = parentMenu.parentMenu;\n      }\n\n      menu.setElevation(depth);\n    }\n  }\n\n  // set state rather than toggle to support triggers sharing a menu\n  private _setIsMenuOpen(isOpen: boolean): void {\n    if (isOpen !== this._menuOpen) {\n      this._menuOpen = isOpen;\n      this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n\n      if (this.triggersSubmenu()) {\n        this._menuItemInstance._setHighlighted(isOpen);\n      }\n\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**\n   * This method creates the overlay from the provided menu's template and saves its\n   * OverlayRef so that it can be attached to the DOM when openMenu is called.\n   */\n  private _createOverlay(menu: MatMenuPanel): OverlayRef {\n    if (!this._overlayRef) {\n      const config = this._getOverlayConfig(menu);\n      this._subscribeToPositions(\n        menu,\n        config.positionStrategy as FlexibleConnectedPositionStrategy,\n      );\n      this._overlayRef = this._overlay.create(config);\n\n      // Consume the `keydownEvents` in order to prevent them from going to another overlay.\n      // Ideally we'd also have our keyboard event logic in here, however doing so will\n      // break anybody that may have implemented the `MatMenuPanel` themselves.\n      this._overlayRef.keydownEvents().subscribe();\n    }\n\n    return this._overlayRef;\n  }\n\n  /**\n   * This method builds the configuration object needed to create the overlay, the OverlayState.\n   * @returns OverlayConfig\n   */\n  private _getOverlayConfig(menu: MatMenuPanel): OverlayConfig {\n    return new OverlayConfig({\n      positionStrategy: this._overlay\n        .position()\n        .flexibleConnectedTo(this._element)\n        .withLockedPosition()\n        .withGrowAfterOpen()\n        .withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),\n      backdropClass: menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n      panelClass: menu.overlayPanelClass,\n      scrollStrategy: this._scrollStrategy(),\n      direction: this._dir,\n    });\n  }\n\n  /**\n   * Listens to changes in the position of the overlay and sets the correct classes\n   * on the menu based on the new position. This ensures the animation origin is always\n   * correct, even if a fallback position is used for the overlay.\n   */\n  private _subscribeToPositions(menu: MatMenuPanel, position: FlexibleConnectedPositionStrategy) {\n    if (menu.setPositionClasses) {\n      position.positionChanges.subscribe(change => {\n        const posX: MenuPositionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n        const posY: MenuPositionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n\n        // @breaking-change 15.0.0 Remove null check for `ngZone`.\n        // `positionChanges` fires outside of the `ngZone` and `setPositionClasses` might be\n        // updating something in the view so we need to bring it back in.\n        if (this._ngZone) {\n          this._ngZone.run(() => menu.setPositionClasses!(posX, posY));\n        } else {\n          menu.setPositionClasses!(posX, posY);\n        }\n      });\n    }\n  }\n\n  /**\n   * Sets the appropriate positions on a position strategy\n   * so the overlay connects with the trigger correctly.\n   * @param positionStrategy Strategy whose position to update.\n   */\n  private _setPosition(menu: MatMenuPanel, positionStrategy: FlexibleConnectedPositionStrategy) {\n    let [originX, originFallbackX]: HorizontalConnectionPos[] =\n      menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n\n    let [overlayY, overlayFallbackY]: VerticalConnectionPos[] =\n      menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n\n    let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n    let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n    let offsetY = 0;\n\n    if (this.triggersSubmenu()) {\n      // When the menu is a sub-menu, it should always align itself\n      // to the edges of the trigger, instead of overlapping it.\n      overlayFallbackX = originX = menu.xPosition === 'before' ? 'start' : 'end';\n      originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n\n      if (this._parentMaterialMenu) {\n        if (this._parentInnerPadding == null) {\n          const firstItem = this._parentMaterialMenu.items.first;\n          this._parentInnerPadding = firstItem ? firstItem._getHostElement().offsetTop : 0;\n        }\n\n        offsetY = overlayY === 'bottom' ? this._parentInnerPadding : -this._parentInnerPadding;\n      }\n    } else if (!menu.overlapTrigger) {\n      originY = overlayY === 'top' ? 'bottom' : 'top';\n      originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n    }\n\n    positionStrategy.withPositions([\n      {originX, originY, overlayX, overlayY, offsetY},\n      {originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY},\n      {\n        originX,\n        originY: originFallbackY,\n        overlayX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY,\n      },\n      {\n        originX: originFallbackX,\n        originY: originFallbackY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY,\n      },\n    ]);\n  }\n\n  /** Returns a stream that emits whenever an action that should close the menu occurs. */\n  private _menuClosingActions() {\n    const backdrop = this._overlayRef!.backdropClick();\n    const detachments = this._overlayRef!.detachments();\n    const parentClose = this._parentMaterialMenu ? this._parentMaterialMenu.closed : observableOf();\n    const hover = this._parentMaterialMenu\n      ? this._parentMaterialMenu._hovered().pipe(\n          filter(active => active !== this._menuItemInstance),\n          filter(() => this._menuOpen),\n        )\n      : observableOf();\n\n    return merge(backdrop, parentClose as Observable<MenuCloseReason>, hover, detachments);\n  }\n\n  /** Handles mouse presses on the trigger. */\n  _handleMousedown(event: MouseEvent): void {\n    if (!isFakeMousedownFromScreenReader(event)) {\n      // Since right or middle button clicks won't trigger the `click` event,\n      // we shouldn't consider the menu as opened by mouse in those cases.\n      this._openedBy = event.button === 0 ? 'mouse' : undefined;\n\n      // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n      // we should prevent focus from moving onto it via click to avoid the\n      // highlight from lingering on the menu item.\n      if (this.triggersSubmenu()) {\n        event.preventDefault();\n      }\n    }\n  }\n\n  /** Handles key presses on the trigger. */\n  _handleKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n\n    // Pressing enter on the trigger will trigger the click handler later.\n    if (keyCode === ENTER || keyCode === SPACE) {\n      this._openedBy = 'keyboard';\n    }\n\n    if (\n      this.triggersSubmenu() &&\n      ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n        (keyCode === LEFT_ARROW && this.dir === 'rtl'))\n    ) {\n      this._openedBy = 'keyboard';\n      this.openMenu();\n    }\n  }\n\n  /** Handles click events on the trigger. */\n  _handleClick(event: MouseEvent): void {\n    if (this.triggersSubmenu()) {\n      // Stop event propagation to avoid closing the parent menu.\n      event.stopPropagation();\n      this.openMenu();\n    } else {\n      this.toggleMenu();\n    }\n  }\n\n  /** Handles the cases where the user hovers over the trigger. */\n  private _handleHover() {\n    // Subscribe to changes in the hovered item in order to toggle the panel.\n    if (!this.triggersSubmenu() || !this._parentMaterialMenu) {\n      return;\n    }\n\n    this._hoverSubscription = this._parentMaterialMenu\n      ._hovered()\n      // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\n      // with different data and triggers), we have to delay it by a tick to ensure that\n      // it won't be closed immediately after it is opened.\n      .pipe(\n        filter(active => active === this._menuItemInstance && !active.disabled),\n        delay(0, asapScheduler),\n      )\n      .subscribe(() => {\n        this._openedBy = 'mouse';\n\n        // If the same menu is used between multiple triggers, it might still be animating\n        // while the new trigger tries to re-open it. Wait for the animation to finish\n        // before doing so. Also interrupt if the user moves to another item.\n        if (this.menu instanceof MatMenu && this.menu._isAnimating) {\n          // We need the `delay(0)` here in order to avoid\n          // 'changed after checked' errors in some cases. See #12194.\n          this.menu._animationDone\n            .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMaterialMenu!._hovered()))\n            .subscribe(() => this.openMenu());\n        } else {\n          this.openMenu();\n        }\n      });\n  }\n\n  /** Gets the portal that should be attached to the overlay. */\n  private _getPortal(menu: MatMenuPanel): TemplatePortal {\n    // Note that we can avoid this check by keeping the portal on the menu panel.\n    // While it would be cleaner, we'd have to introduce another required method on\n    // `MatMenuPanel`, making it harder to consume.\n    if (!this._portal || this._portal.templateRef !== menu.templateRef) {\n      this._portal = new TemplatePortal(menu.templateRef, this._viewContainerRef);\n    }\n\n    return this._portal;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MatMenu} from './menu';\nimport {MatMenuItem} from './menu-item';\nimport {MatMenuContent} from './menu-content';\nimport {MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER, MatMenuTrigger} from './menu-trigger';\n\n@NgModule({\n  imports: [CommonModule, MatRippleModule, MatCommonModule, OverlayModule],\n  exports: [\n    CdkScrollableModule,\n    MatMenu,\n    MatCommonModule,\n    MatMenuItem,\n    MatMenuContent,\n    MatMenuTrigger,\n  ],\n  declarations: [MatMenu, MatMenuItem, MatMenuContent, MatMenuTrigger],\n  providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER],\n})\nexport class MatMenuModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["_c0", "MatMenuItem_Conditional_4_Template", "rf", "ctx", "_c1", "_c2", "MatMenu_ng_template_0_Template", "_r2", "ctx_r1", "_handleKeydown", "$event", "MatMenu_ng_template_0_Template_div_click_0_listener", "ctx_r3", "closed", "emit", "MatMenu_ng_template_0_Template_div_animation_transformMenu_start_0_listener", "ctx_r4", "_onAnimationStart", "MatMenu_ng_template_0_Template_div_animation_transformMenu_done_0_listener", "ctx_r5", "_onAnimationDone", "ctx_r0", "_classList", "_panelAnimationState", "ariaLabelledby", "ariaDescribedby", "_c3", "MAT_MENU_PANEL", "InjectionToken", "MatMenuItem", "constructor", "_elementRef", "_document", "_focusMonitor", "_parentMenu", "_changeDetectorRef", "role", "disabled", "disableRipple", "_hovered", "Subject", "_focused", "_highlighted", "_triggersSubmenu", "addItem", "focus", "origin", "options", "focusVia", "_getHostElement", "next", "ngAfterViewInit", "monitor", "ngOnDestroy", "stopMonitoring", "removeItem", "complete", "_getTabIndex", "nativeElement", "_checkDisabled", "event", "preventDefault", "stopPropagation", "_handleMouseEnter", "getLabel", "clone", "cloneNode", "icons", "querySelectorAll", "i", "length", "remove", "textContent", "trim", "_setHighlighted", "isHighlighted", "markForCheck", "_setTriggersSubmenu", "triggersSubmenu", "_hasFocus", "activeElement", "ElementRef", "DOCUMENT", "FocusMonitor", "ChangeDetectorRef", "cmp", "selectors", "hostAttrs", "hostVars", "hostBindings", "MatMenuItem_HostBindings", "MatMenuItem_mouseenter_HostBindingHandler", "booleanAttribute", "exportAs", "features", "dependencies", "MatRipple", "encapsulation", "changeDetection", "Component", "host", "ChangeDetectionStrategy", "OnPush", "ViewEncapsulation", "None", "template", "Inject", "Optional", "Input", "transform", "throwMatMenuInvalidPositionX", "Error", "throwMatMenuInvalidPositionY", "throwMatMenuRecursiveError", "MAT_MENU_CONTENT", "MatMenuContent", "_template", "_componentFactoryResolver", "_appRef", "_injector", "_viewContainerRef", "_attached", "attach", "context", "_portal", "TemplatePortal", "detach", "_outlet", "DomPortalOutlet", "createElement", "element", "elementRef", "parentNode", "insertBefore", "outletElement", "isAttached", "dispose", "fac", "MatMenuContent_Factory", "t", "TemplateRef", "ComponentFactoryResolver", "ApplicationRef", "Injector", "ViewContainerRef", "provide", "useExisting", "Directive", "args", "selector", "providers", "matMenuAnimations", "transformMenu", "trigger", "state", "style", "opacity", "transition", "animate", "fadeInItems", "menuPanelUid", "MAT_MENU_DEFAULT_OPTIONS", "providedIn", "factory", "MAT_MENU_DEFAULT_OPTIONS_FACTORY", "overlapTrigger", "xPosition", "yPosition", "backdropClass", "MatMenu", "_xPosition", "value", "ngDevMode", "setPositionClasses", "_yPosition", "panelClass", "classes", "previousPanelClass", "_previousPanelClass", "split", "forEach", "className", "classList", "_ngZone", "defaultOptions", "_elevationPrefix", "_baseElevation", "_directDescendantItems", "QueryList", "_animationDone", "EventEmitter", "close", "panelId", "overlayPanelClass", "hasBackdrop", "ngOnInit", "ngAfterContentInit", "_updateDirectDescendants", "_keyManager", "FocusKeyManager", "withWrap", "withTypeAhead", "withHomeAndEnd", "tabOut", "subscribe", "changes", "pipe", "startWith", "switchMap", "items", "merge", "map", "item", "focusedItem", "updateActiveItem", "itemsList", "manager", "activeItem", "toArray", "index", "Math", "max", "min", "activeItemIndex", "setActiveItem", "setNextItemActive", "destroy", "_firstItemFocusSubscription", "unsubscribe", "itemChanges", "_item", "keyCode", "ESCAPE", "hasModifierKey", "LEFT_ARROW", "parentMenu", "direction", "RIGHT_ARROW", "UP_ARROW", "DOWN_ARROW", "setFocusOrigin", "onKeydown", "focusFirstItem", "onStable", "take", "menuPanel", "first", "closest", "contains", "document", "setFirstItemActive", "resetActiveItem", "setElevation", "depth", "elevation", "newElevation", "customElevation", "Object", "keys", "find", "startsWith", "_previousElevation", "posX", "posY", "_startAnimation", "_resetAnimation", "_isAnimating", "toState", "scrollTop", "_allItems", "reset", "filter", "notifyOnChanges", "MatMenu_Factory", "NgZone", "contentQueries", "MatMenu_ContentQueries", "dirIndex", "_t", "MatMenu_HostBindings", "outputs", "NgClass", "styles", "data", "animation", "animations", "ContentChildren", "descendants", "ariaLabel", "templateRef", "ViewChild", "lazyContent", "ContentChild", "Output", "MAT_MENU_SCROLL_STRATEGY", "MAT_MENU_SCROLL_STRATEGY_FACTORY", "overlay", "scrollStrategies", "reposition", "MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER", "deps", "Overlay", "useFactory", "passiveEventListenerOptions", "normalizePassiveListenerOptions", "passive", "MENU_PANEL_TOP_PADDING", "MatMenuTrigger", "_deprecatedMatMenuTriggerFor", "menu", "v", "_menu", "_menuCloseSubscription", "_parentMaterialMenu", "reason", "_destroyMenu", "_menuItemInstance", "_overlay", "_element", "scrollStrategy", "_dir", "_overlayRef", "_menuOpen", "_closingActionsSubscription", "Subscription", "EMPTY", "_hoverSubscription", "inject", "_handleTouchStart", "isFakeTouchstartFromScreenReader", "_openedBy", "undefined", "restoreFocus", "menuOpened", "onMenuOpen", "menuClosed", "onMenuClose", "_scrollStrategy", "addEventListener", "_handleHover", "removeEventListener", "menuOpen", "dir", "toggleMenu", "closeMenu", "openMenu", "overlayRef", "_createOverlay", "overlayConfig", "getConfig", "positionStrategy", "_setPosition", "_getPortal", "menuData", "_menuClosingActions", "_initMenu", "takeUntil", "withLockedPosition", "reapplyLastPosition", "updatePosition", "_setIsMenuOpen", "_setMenuElevation", "isOpen", "config", "_getOverlayConfig", "_subscribeToPositions", "create", "keydownEvents", "OverlayConfig", "position", "flexibleConnectedTo", "withGrowAfterOpen", "withTransformOriginOn", "positionChanges", "change", "connectionPair", "overlayX", "overlayY", "run", "originX", "originFallbackX", "overlayFallbackY", "originY", "originFallbackY", "overlayFallbackX", "offsetY", "_parentInnerPadding", "firstItem", "offsetTop", "withPositions", "backdrop", "backdropClick", "detachments", "parentClose", "of", "hover", "active", "_handleMousedown", "isFakeMousedownFromScreenReader", "button", "ENTER", "SPACE", "_handleClick", "delay", "asapScheduler", "Directionality", "MatMenuTrigger_HostBindings", "MatMenuTrigger_mousedown_HostBindingHandler", "MatMenuTrigger_keydown_HostBindingHandler", "Self", "MatMenuModule", "mod", "declarations", "imports", "CommonModule", "MatRippleModule", "MatCommonModule", "OverlayModule", "exports", "CdkScrollableModule", "inj", "NgModule"]
}
