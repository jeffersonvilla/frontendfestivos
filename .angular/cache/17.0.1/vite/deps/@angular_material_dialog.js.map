{
  "version": 3,
  "sources": ["../../../../../../../src/cdk/dialog/dialog-config.ts", "../../../../../../../src/cdk/dialog/dialog-container.ts", "../../../../../../../src/cdk/dialog/dialog-container.html", "../../../../../../../src/cdk/dialog/dialog-ref.ts", "../../../../../../../src/cdk/dialog/dialog-injectors.ts", "../../../../../../../src/cdk/dialog/dialog.ts", "../../../../../../../src/cdk/dialog/dialog-module.ts", "../../../../../../../src/cdk/dialog/dialog_public_index.ts", "../../../../../../../src/material/dialog/dialog-config.ts", "../../../../../../../src/material/dialog/dialog-container.ts", "../../../../../../../src/material/dialog/dialog-container.html", "../../../../../../../src/material/dialog/dialog-ref.ts", "../../../../../../../src/material/dialog/dialog.ts", "../../../../../../../src/material/dialog/dialog-content-directives.ts", "../../../../../../../src/material/dialog/module.ts", "../../../../../../../src/material/dialog/dialog-animations.ts", "../../../../../../../src/material/dialog/dialog_public_index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ViewContainerRef,\n  ComponentFactoryResolver,\n  Injector,\n  StaticProvider,\n  Type,\n} from '@angular/core';\nimport {Direction} from '@angular/cdk/bidi';\nimport {PositionStrategy, ScrollStrategy} from '@angular/cdk/overlay';\nimport {BasePortalOutlet} from '@angular/cdk/portal';\n\n/** Options for where to set focus to automatically on dialog open */\nexport type AutoFocusTarget = 'dialog' | 'first-tabbable' | 'first-heading';\n\n/** Valid ARIA roles for a dialog. */\nexport type DialogRole = 'dialog' | 'alertdialog';\n\n/** Configuration for opening a modal dialog. */\nexport class DialogConfig<D = unknown, R = unknown, C extends BasePortalOutlet = BasePortalOutlet> {\n  /**\n   * Where the attached component should live in Angular's *logical* component tree.\n   * This affects what is available for injection and the change detection order for the\n   * component instantiated inside of the dialog. This does not affect where the dialog\n   * content will be rendered.\n   */\n  viewContainerRef?: ViewContainerRef;\n\n  /**\n   * Injector used for the instantiation of the component to be attached. If provided,\n   * takes precedence over the injector indirectly provided by `ViewContainerRef`.\n   */\n  injector?: Injector;\n\n  /** ID for the dialog. If omitted, a unique one will be generated. */\n  id?: string;\n\n  /** The ARIA role of the dialog element. */\n  role?: DialogRole = 'dialog';\n\n  /** Optional CSS class or classes applied to the overlay panel. */\n  panelClass?: string | string[] = '';\n\n  /** Whether the dialog has a backdrop. */\n  hasBackdrop?: boolean = true;\n\n  /** Optional CSS class or classes applied to the overlay backdrop. */\n  backdropClass?: string | string[] = '';\n\n  /** Whether the dialog closes with the escape key or pointer events outside the panel element. */\n  disableClose?: boolean = false;\n\n  /** Width of the dialog. */\n  width?: string = '';\n\n  /** Height of the dialog. */\n  height?: string = '';\n\n  /** Min-width of the dialog. If a number is provided, assumes pixel units. */\n  minWidth?: number | string;\n\n  /** Min-height of the dialog. If a number is provided, assumes pixel units. */\n  minHeight?: number | string;\n\n  /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */\n  maxWidth?: number | string;\n\n  /** Max-height of the dialog. If a number is provided, assumes pixel units. */\n  maxHeight?: number | string;\n\n  /** Strategy to use when positioning the dialog. Defaults to centering it on the page. */\n  positionStrategy?: PositionStrategy;\n\n  /** Data being injected into the child component. */\n  data?: D | null = null;\n\n  /** Layout direction for the dialog's content. */\n  direction?: Direction;\n\n  /** ID of the element that describes the dialog. */\n  ariaDescribedBy?: string | null = null;\n\n  /** ID of the element that labels the dialog. */\n  ariaLabelledBy?: string | null = null;\n\n  /** Dialog label applied via `aria-label` */\n  ariaLabel?: string | null = null;\n\n  /** Whether this is a modal dialog. Used to set the `aria-modal` attribute. */\n  ariaModal?: boolean = true;\n\n  /**\n   * Where the dialog should focus on open.\n   * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or\n   * AutoFocusTarget instead.\n   */\n  autoFocus?: AutoFocusTarget | string | boolean = 'first-tabbable';\n\n  /**\n   * Whether the dialog should restore focus to the previously-focused element upon closing.\n   * Has the following behavior based on the type that is passed in:\n   * - `boolean` - when true, will return focus to the element that was focused before the dialog\n   *    was opened, otherwise won't restore focus at all.\n   * - `string` - focus will be restored to the first element that matches the CSS selector.\n   * - `HTMLElement` - focus will be restored to the specific element.\n   */\n  restoreFocus?: boolean | string | HTMLElement = true;\n\n  /**\n   * Scroll strategy to be used for the dialog. This determines how\n   * the dialog responds to scrolling underneath the panel element.\n   */\n  scrollStrategy?: ScrollStrategy;\n\n  /**\n   * Whether the dialog should close when the user navigates backwards or forwards through browser\n   * history. This does not apply to navigation via anchor element unless using URL-hash based\n   * routing (`HashLocationStrategy` in the Angular router).\n   */\n  closeOnNavigation?: boolean = true;\n\n  /**\n   * Whether the dialog should close when the dialog service is destroyed. This is useful if\n   * another service is wrapping the dialog and is managing the destruction instead.\n   */\n  closeOnDestroy?: boolean = true;\n\n  /**\n   * Whether the dialog should close when the underlying overlay is detached. This is useful if\n   * another service is wrapping the dialog and is managing the destruction instead. E.g. an\n   * external detachment can happen as a result of a scroll strategy triggering it or when the\n   * browser location changes.\n   */\n  closeOnOverlayDetachments?: boolean = true;\n\n  /** Alternate `ComponentFactoryResolver` to use when resolving the associated component. */\n  componentFactoryResolver?: ComponentFactoryResolver;\n\n  /**\n   * Providers that will be exposed to the contents of the dialog. Can also\n   * be provided as a function in order to generate the providers lazily.\n   */\n  providers?:\n    | StaticProvider[]\n    | ((dialogRef: R, config: DialogConfig<D, R, C>, container: C) => StaticProvider[]);\n\n  /**\n   * Component into which the dialog content will be rendered. Defaults to `CdkDialogContainer`.\n   * A configuration object can be passed in to customize the providers that will be exposed\n   * to the dialog container.\n   */\n  container?:\n    | Type<C>\n    | {\n        type: Type<C>;\n        providers: (config: DialogConfig<D, R, C>) => StaticProvider[];\n      };\n\n  /**\n   * Context that will be passed to template-based dialogs.\n   * A function can be passed in to resolve the context lazily.\n   */\n  templateContext?: Record<string, any> | (() => Record<string, any>);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  FocusMonitor,\n  FocusOrigin,\n  FocusTrap,\n  FocusTrapFactory,\n  InteractivityChecker,\n} from '@angular/cdk/a11y';\nimport {OverlayRef} from '@angular/cdk/overlay';\nimport {_getFocusedElementPierceShadowDom} from '@angular/cdk/platform';\nimport {\n  BasePortalOutlet,\n  CdkPortalOutlet,\n  ComponentPortal,\n  DomPortal,\n  PortalModule,\n  TemplatePortal,\n} from '@angular/cdk/portal';\nimport {DOCUMENT} from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ComponentRef,\n  ElementRef,\n  EmbeddedViewRef,\n  Inject,\n  NgZone,\n  OnDestroy,\n  Optional,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {DialogConfig} from './dialog-config';\n\nexport function throwDialogContentAlreadyAttachedError() {\n  throw Error('Attempting to attach dialog content after content is already attached');\n}\n\n/**\n * Internal component that wraps user-provided dialog content.\n * @docs-private\n */\n@Component({\n  selector: 'cdk-dialog-container',\n  templateUrl: './dialog-container.html',\n  styleUrls: ['dialog-container.css'],\n  encapsulation: ViewEncapsulation.None,\n  // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  standalone: true,\n  imports: [PortalModule],\n  host: {\n    'class': 'cdk-dialog-container',\n    'tabindex': '-1',\n    '[attr.id]': '_config.id || null',\n    '[attr.role]': '_config.role',\n    '[attr.aria-modal]': '_config.ariaModal',\n    '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledByQueue[0]',\n    '[attr.aria-label]': '_config.ariaLabel',\n    '[attr.aria-describedby]': '_config.ariaDescribedBy || null',\n  },\n})\nexport class CdkDialogContainer<C extends DialogConfig = DialogConfig>\n  extends BasePortalOutlet\n  implements OnDestroy\n{\n  protected _document: Document;\n\n  /** The portal outlet inside of this container into which the dialog content will be loaded. */\n  @ViewChild(CdkPortalOutlet, {static: true}) _portalOutlet: CdkPortalOutlet;\n\n  /** The class that traps and manages focus within the dialog. */\n  private _focusTrap: FocusTrap;\n\n  /** Element that was focused before the dialog was opened. Save this to restore upon close. */\n  private _elementFocusedBeforeDialogWasOpened: HTMLElement | null = null;\n\n  /**\n   * Type of interaction that led to the dialog being closed. This is used to determine\n   * whether the focus style will be applied when returning focus to its original location\n   * after the dialog is closed.\n   */\n  _closeInteractionType: FocusOrigin | null = null;\n\n  /**\n   * Queue of the IDs of the dialog's label element, based on their definition order. The first\n   * ID will be used as the `aria-labelledby` value. We use a queue here to handle the case\n   * where there are two or more titles in the DOM at a time and the first one is destroyed while\n   * the rest are present.\n   */\n  _ariaLabelledByQueue: string[] = [];\n\n  constructor(\n    protected _elementRef: ElementRef,\n    protected _focusTrapFactory: FocusTrapFactory,\n    @Optional() @Inject(DOCUMENT) _document: any,\n    @Inject(DialogConfig) readonly _config: C,\n    private _interactivityChecker: InteractivityChecker,\n    protected _ngZone: NgZone,\n    private _overlayRef: OverlayRef,\n    private _focusMonitor?: FocusMonitor,\n  ) {\n    super();\n\n    this._document = _document;\n\n    if (this._config.ariaLabelledBy) {\n      this._ariaLabelledByQueue.push(this._config.ariaLabelledBy);\n    }\n  }\n\n  protected _contentAttached() {\n    this._initializeFocusTrap();\n    this._handleBackdropClicks();\n    this._captureInitialFocus();\n  }\n\n  /**\n   * Can be used by child classes to customize the initial focus\n   * capturing behavior (e.g. if it's tied to an animation).\n   */\n  protected _captureInitialFocus() {\n    this._trapFocus();\n  }\n\n  ngOnDestroy() {\n    this._restoreFocus();\n  }\n\n  /**\n   * Attach a ComponentPortal as content to this dialog container.\n   * @param portal Portal to be attached as the dialog content.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwDialogContentAlreadyAttachedError();\n    }\n\n    const result = this._portalOutlet.attachComponentPortal(portal);\n    this._contentAttached();\n    return result;\n  }\n\n  /**\n   * Attach a TemplatePortal as content to this dialog container.\n   * @param portal Portal to be attached as the dialog content.\n   */\n  attachTemplatePortal<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T> {\n    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwDialogContentAlreadyAttachedError();\n    }\n\n    const result = this._portalOutlet.attachTemplatePortal(portal);\n    this._contentAttached();\n    return result;\n  }\n\n  /**\n   * Attaches a DOM portal to the dialog container.\n   * @param portal Portal to be attached.\n   * @deprecated To be turned into a method.\n   * @breaking-change 10.0.0\n   */\n  override attachDomPortal = (portal: DomPortal) => {\n    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwDialogContentAlreadyAttachedError();\n    }\n\n    const result = this._portalOutlet.attachDomPortal(portal);\n    this._contentAttached();\n    return result;\n  };\n\n  // TODO(crisbeto): this shouldn't be exposed, but there are internal references to it.\n  /** Captures focus if it isn't already inside the dialog. */\n  _recaptureFocus() {\n    if (!this._containsFocus()) {\n      this._trapFocus();\n    }\n  }\n\n  /**\n   * Focuses the provided element. If the element is not focusable, it will add a tabIndex\n   * attribute to forcefully focus it. The attribute is removed after focus is moved.\n   * @param element The element to focus.\n   */\n  private _forceFocus(element: HTMLElement, options?: FocusOptions) {\n    if (!this._interactivityChecker.isFocusable(element)) {\n      element.tabIndex = -1;\n      // The tabindex attribute should be removed to avoid navigating to that element again\n      this._ngZone.runOutsideAngular(() => {\n        const callback = () => {\n          element.removeEventListener('blur', callback);\n          element.removeEventListener('mousedown', callback);\n          element.removeAttribute('tabindex');\n        };\n\n        element.addEventListener('blur', callback);\n        element.addEventListener('mousedown', callback);\n      });\n    }\n    element.focus(options);\n  }\n\n  /**\n   * Focuses the first element that matches the given selector within the focus trap.\n   * @param selector The CSS selector for the element to set focus to.\n   */\n  private _focusByCssSelector(selector: string, options?: FocusOptions) {\n    let elementToFocus = this._elementRef.nativeElement.querySelector(\n      selector,\n    ) as HTMLElement | null;\n    if (elementToFocus) {\n      this._forceFocus(elementToFocus, options);\n    }\n  }\n\n  /**\n   * Moves the focus inside the focus trap. When autoFocus is not set to 'dialog', if focus\n   * cannot be moved then focus will go to the dialog container.\n   */\n  protected _trapFocus() {\n    const element = this._elementRef.nativeElement;\n    // If were to attempt to focus immediately, then the content of the dialog would not yet be\n    // ready in instances where change detection has to run first. To deal with this, we simply\n    // wait for the microtask queue to be empty when setting focus when autoFocus isn't set to\n    // dialog. If the element inside the dialog can't be focused, then the container is focused\n    // so the user can't tab into other elements behind it.\n    switch (this._config.autoFocus) {\n      case false:\n      case 'dialog':\n        // Ensure that focus is on the dialog container. It's possible that a different\n        // component tried to move focus while the open animation was running. See:\n        // https://github.com/angular/components/issues/16215. Note that we only want to do this\n        // if the focus isn't inside the dialog already, because it's possible that the consumer\n        // turned off `autoFocus` in order to move focus themselves.\n        if (!this._containsFocus()) {\n          element.focus();\n        }\n        break;\n      case true:\n      case 'first-tabbable':\n        this._focusTrap.focusInitialElementWhenReady().then(focusedSuccessfully => {\n          // If we weren't able to find a focusable element in the dialog, then focus the dialog\n          // container instead.\n          if (!focusedSuccessfully) {\n            this._focusDialogContainer();\n          }\n        });\n        break;\n      case 'first-heading':\n        this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role=\"heading\"]');\n        break;\n      default:\n        this._focusByCssSelector(this._config.autoFocus!);\n        break;\n    }\n  }\n\n  /** Restores focus to the element that was focused before the dialog opened. */\n  private _restoreFocus() {\n    const focusConfig = this._config.restoreFocus;\n    let focusTargetElement: HTMLElement | null = null;\n\n    if (typeof focusConfig === 'string') {\n      focusTargetElement = this._document.querySelector(focusConfig);\n    } else if (typeof focusConfig === 'boolean') {\n      focusTargetElement = focusConfig ? this._elementFocusedBeforeDialogWasOpened : null;\n    } else if (focusConfig) {\n      focusTargetElement = focusConfig;\n    }\n\n    // We need the extra check, because IE can set the `activeElement` to null in some cases.\n    if (\n      this._config.restoreFocus &&\n      focusTargetElement &&\n      typeof focusTargetElement.focus === 'function'\n    ) {\n      const activeElement = _getFocusedElementPierceShadowDom();\n      const element = this._elementRef.nativeElement;\n\n      // Make sure that focus is still inside the dialog or is on the body (usually because a\n      // non-focusable element like the backdrop was clicked) before moving it. It's possible that\n      // the consumer moved it themselves before the animation was done, in which case we shouldn't\n      // do anything.\n      if (\n        !activeElement ||\n        activeElement === this._document.body ||\n        activeElement === element ||\n        element.contains(activeElement)\n      ) {\n        if (this._focusMonitor) {\n          this._focusMonitor.focusVia(focusTargetElement, this._closeInteractionType);\n          this._closeInteractionType = null;\n        } else {\n          focusTargetElement.focus();\n        }\n      }\n    }\n\n    if (this._focusTrap) {\n      this._focusTrap.destroy();\n    }\n  }\n\n  /** Focuses the dialog container. */\n  private _focusDialogContainer() {\n    // Note that there is no focus method when rendering on the server.\n    if (this._elementRef.nativeElement.focus) {\n      this._elementRef.nativeElement.focus();\n    }\n  }\n\n  /** Returns whether focus is inside the dialog. */\n  private _containsFocus() {\n    const element = this._elementRef.nativeElement;\n    const activeElement = _getFocusedElementPierceShadowDom();\n    return element === activeElement || element.contains(activeElement);\n  }\n\n  /** Sets up the focus trap. */\n  private _initializeFocusTrap() {\n    this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n\n    // Save the previously focused element. This element will be re-focused\n    // when the dialog closes.\n    if (this._document) {\n      this._elementFocusedBeforeDialogWasOpened = _getFocusedElementPierceShadowDom();\n    }\n  }\n\n  /** Sets up the listener that handles clicks on the dialog backdrop. */\n  private _handleBackdropClicks() {\n    // Clicking on the backdrop will move focus out of dialog.\n    // Recapture it if closing via the backdrop is disabled.\n    this._overlayRef.backdropClick().subscribe(() => {\n      if (this._config.disableClose) {\n        this._recaptureFocus();\n      }\n    });\n  }\n}\n", "<ng-template cdkPortalOutlet></ng-template>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OverlayRef} from '@angular/cdk/overlay';\nimport {ESCAPE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {Observable, Subject, Subscription} from 'rxjs';\nimport {DialogConfig} from './dialog-config';\nimport {FocusOrigin} from '@angular/cdk/a11y';\nimport {BasePortalOutlet} from '@angular/cdk/portal';\nimport {ComponentRef} from '@angular/core';\n\n/** Additional options that can be passed in when closing a dialog. */\nexport interface DialogCloseOptions {\n  /** Focus original to use when restoring focus. */\n  focusOrigin?: FocusOrigin;\n}\n\n/**\n * Reference to a dialog opened via the Dialog service.\n */\nexport class DialogRef<R = unknown, C = unknown> {\n  /**\n   * Instance of component opened into the dialog. Will be\n   * null when the dialog is opened using a `TemplateRef`.\n   */\n  readonly componentInstance: C | null;\n\n  /**\n   * `ComponentRef` of the component opened into the dialog. Will be\n   * null when the dialog is opened using a `TemplateRef`.\n   */\n  readonly componentRef: ComponentRef<C> | null;\n\n  /** Instance of the container that is rendering out the dialog content. */\n  readonly containerInstance: BasePortalOutlet & {_closeInteractionType?: FocusOrigin};\n\n  /** Whether the user is allowed to close the dialog. */\n  disableClose: boolean | undefined;\n\n  /** Emits when the dialog has been closed. */\n  readonly closed: Observable<R | undefined> = new Subject<R | undefined>();\n\n  /** Emits when the backdrop of the dialog is clicked. */\n  readonly backdropClick: Observable<MouseEvent>;\n\n  /** Emits when on keyboard events within the dialog. */\n  readonly keydownEvents: Observable<KeyboardEvent>;\n\n  /** Emits on pointer events that happen outside of the dialog. */\n  readonly outsidePointerEvents: Observable<MouseEvent>;\n\n  /** Unique ID for the dialog. */\n  readonly id: string;\n\n  /** Subscription to external detachments of the dialog. */\n  private _detachSubscription: Subscription;\n\n  constructor(\n    readonly overlayRef: OverlayRef,\n    readonly config: DialogConfig<any, DialogRef<R, C>, BasePortalOutlet>,\n  ) {\n    this.disableClose = config.disableClose;\n    this.backdropClick = overlayRef.backdropClick();\n    this.keydownEvents = overlayRef.keydownEvents();\n    this.outsidePointerEvents = overlayRef.outsidePointerEvents();\n    this.id = config.id!; // By the time the dialog is created we are guaranteed to have an ID.\n\n    this.keydownEvents.subscribe(event => {\n      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n        event.preventDefault();\n        this.close(undefined, {focusOrigin: 'keyboard'});\n      }\n    });\n\n    this.backdropClick.subscribe(() => {\n      if (!this.disableClose) {\n        this.close(undefined, {focusOrigin: 'mouse'});\n      }\n    });\n\n    this._detachSubscription = overlayRef.detachments().subscribe(() => {\n      // Check specifically for `false`, because we want `undefined` to be treated like `true`.\n      if (config.closeOnOverlayDetachments !== false) {\n        this.close();\n      }\n    });\n  }\n\n  /**\n   * Close the dialog.\n   * @param result Optional result to return to the dialog opener.\n   * @param options Additional options to customize the closing behavior.\n   */\n  close(result?: R, options?: DialogCloseOptions): void {\n    if (this.containerInstance) {\n      const closedSubject = this.closed as Subject<R | undefined>;\n      this.containerInstance._closeInteractionType = options?.focusOrigin || 'program';\n      // Drop the detach subscription first since it can be triggered by the\n      // `dispose` call and override the result of this closing sequence.\n      this._detachSubscription.unsubscribe();\n      this.overlayRef.dispose();\n      closedSubject.next(result);\n      closedSubject.complete();\n      (this as {componentInstance: C}).componentInstance = (\n        this as {containerInstance: BasePortalOutlet}\n      ).containerInstance = null!;\n    }\n  }\n\n  /** Updates the position of the dialog based on the current position strategy. */\n  updatePosition(): this {\n    this.overlayRef.updatePosition();\n    return this;\n  }\n\n  /**\n   * Updates the dialog's width and height.\n   * @param width New width of the dialog.\n   * @param height New height of the dialog.\n   */\n  updateSize(width: string | number = '', height: string | number = ''): this {\n    this.overlayRef.updateSize({width, height});\n    return this;\n  }\n\n  /** Add a CSS class or an array of classes to the overlay pane. */\n  addPanelClass(classes: string | string[]): this {\n    this.overlayRef.addPanelClass(classes);\n    return this;\n  }\n\n  /** Remove a CSS class or an array of classes from the overlay pane. */\n  removePanelClass(classes: string | string[]): this {\n    this.overlayRef.removePanelClass(classes);\n    return this;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken, inject} from '@angular/core';\nimport {Overlay, ScrollStrategy} from '@angular/cdk/overlay';\nimport {DialogConfig} from './dialog-config';\n\n/** Injection token for the Dialog's ScrollStrategy. */\nexport const DIALOG_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'DialogScrollStrategy',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const overlay = inject(Overlay);\n      return () => overlay.scrollStrategies.block();\n    },\n  },\n);\n\n/** Injection token for the Dialog's Data. */\nexport const DIALOG_DATA = new InjectionToken<any>('DialogData');\n\n/** Injection token that can be used to provide default options for the dialog module. */\nexport const DEFAULT_DIALOG_CONFIG = new InjectionToken<DialogConfig>('DefaultDialogConfig');\n\n/**\n * @docs-private\n * @deprecated No longer used. To be removed.\n * @breaking-change 19.0.0\n */\nexport function DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.block();\n}\n\n/**\n * @docs-private\n * @deprecated No longer used. To be removed.\n * @breaking-change 19.0.0\n */\nexport const DIALOG_SCROLL_STRATEGY_PROVIDER = {\n  provide: DIALOG_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  TemplateRef,\n  Injectable,\n  Injector,\n  OnDestroy,\n  Type,\n  StaticProvider,\n  Inject,\n  Optional,\n  SkipSelf,\n  ComponentRef,\n} from '@angular/core';\nimport {BasePortalOutlet, ComponentPortal, TemplatePortal} from '@angular/cdk/portal';\nimport {of as observableOf, Observable, Subject, defer} from 'rxjs';\nimport {DialogRef} from './dialog-ref';\nimport {DialogConfig} from './dialog-config';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  ComponentType,\n  Overlay,\n  OverlayRef,\n  OverlayConfig,\n  ScrollStrategy,\n  OverlayContainer,\n} from '@angular/cdk/overlay';\nimport {startWith} from 'rxjs/operators';\n\nimport {DEFAULT_DIALOG_CONFIG, DIALOG_DATA, DIALOG_SCROLL_STRATEGY} from './dialog-injectors';\nimport {CdkDialogContainer} from './dialog-container';\n\n/** Unique id for the created dialog. */\nlet uniqueId = 0;\n\n@Injectable({providedIn: 'root'})\nexport class Dialog implements OnDestroy {\n  private _openDialogsAtThisLevel: DialogRef<any, any>[] = [];\n  private readonly _afterAllClosedAtThisLevel = new Subject<void>();\n  private readonly _afterOpenedAtThisLevel = new Subject<DialogRef>();\n  private _ariaHiddenElements = new Map<Element, string | null>();\n  private _scrollStrategy: () => ScrollStrategy;\n\n  /** Keeps track of the currently-open dialogs. */\n  get openDialogs(): readonly DialogRef<any, any>[] {\n    return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\n  }\n\n  /** Stream that emits when a dialog has been opened. */\n  get afterOpened(): Subject<DialogRef<any, any>> {\n    return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\n  }\n\n  /**\n   * Stream that emits when all open dialog have finished closing.\n   * Will emit on subscribe if there are no open dialogs to begin with.\n   */\n  readonly afterAllClosed: Observable<void> = defer(() =>\n    this.openDialogs.length\n      ? this._getAfterAllClosed()\n      : this._getAfterAllClosed().pipe(startWith(undefined)),\n  );\n\n  constructor(\n    private _overlay: Overlay,\n    private _injector: Injector,\n    @Optional() @Inject(DEFAULT_DIALOG_CONFIG) private _defaultOptions: DialogConfig,\n    @Optional() @SkipSelf() private _parentDialog: Dialog,\n    private _overlayContainer: OverlayContainer,\n    @Inject(DIALOG_SCROLL_STRATEGY) scrollStrategy: any,\n  ) {\n    this._scrollStrategy = scrollStrategy;\n  }\n\n  /**\n   * Opens a modal dialog containing the given component.\n   * @param component Type of the component to load into the dialog.\n   * @param config Extra configuration options.\n   * @returns Reference to the newly-opened dialog.\n   */\n  open<R = unknown, D = unknown, C = unknown>(\n    component: ComponentType<C>,\n    config?: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogRef<R, C>;\n\n  /**\n   * Opens a modal dialog containing the given template.\n   * @param template TemplateRef to instantiate as the dialog content.\n   * @param config Extra configuration options.\n   * @returns Reference to the newly-opened dialog.\n   */\n  open<R = unknown, D = unknown, C = unknown>(\n    template: TemplateRef<C>,\n    config?: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogRef<R, C>;\n\n  open<R = unknown, D = unknown, C = unknown>(\n    componentOrTemplateRef: ComponentType<C> | TemplateRef<C>,\n    config?: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogRef<R, C>;\n\n  open<R = unknown, D = unknown, C = unknown>(\n    componentOrTemplateRef: ComponentType<C> | TemplateRef<C>,\n    config?: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogRef<R, C> {\n    const defaults = (this._defaultOptions || new DialogConfig()) as DialogConfig<\n      D,\n      DialogRef<R, C>\n    >;\n    config = {...defaults, ...config};\n    config.id = config.id || `cdk-dialog-${uniqueId++}`;\n\n    if (\n      config.id &&\n      this.getDialogById(config.id) &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw Error(`Dialog with id \"${config.id}\" exists already. The dialog id must be unique.`);\n    }\n\n    const overlayConfig = this._getOverlayConfig(config);\n    const overlayRef = this._overlay.create(overlayConfig);\n    const dialogRef = new DialogRef(overlayRef, config);\n    const dialogContainer = this._attachContainer(overlayRef, dialogRef, config);\n\n    (dialogRef as {containerInstance: BasePortalOutlet}).containerInstance = dialogContainer;\n    this._attachDialogContent(componentOrTemplateRef, dialogRef, dialogContainer, config);\n\n    // If this is the first dialog that we're opening, hide all the non-overlay content.\n    if (!this.openDialogs.length) {\n      this._hideNonDialogContentFromAssistiveTechnology();\n    }\n\n    (this.openDialogs as DialogRef<R, C>[]).push(dialogRef);\n    dialogRef.closed.subscribe(() => this._removeOpenDialog(dialogRef, true));\n    this.afterOpened.next(dialogRef);\n\n    return dialogRef;\n  }\n\n  /**\n   * Closes all of the currently-open dialogs.\n   */\n  closeAll(): void {\n    reverseForEach(this.openDialogs, dialog => dialog.close());\n  }\n\n  /**\n   * Finds an open dialog by its id.\n   * @param id ID to use when looking up the dialog.\n   */\n  getDialogById<R, C>(id: string): DialogRef<R, C> | undefined {\n    return this.openDialogs.find(dialog => dialog.id === id);\n  }\n\n  ngOnDestroy() {\n    // Make one pass over all the dialogs that need to be untracked, but should not be closed. We\n    // want to stop tracking the open dialog even if it hasn't been closed, because the tracking\n    // determines when `aria-hidden` is removed from elements outside the dialog.\n    reverseForEach(this._openDialogsAtThisLevel, dialog => {\n      // Check for `false` specifically since we want `undefined` to be interpreted as `true`.\n      if (dialog.config.closeOnDestroy === false) {\n        this._removeOpenDialog(dialog, false);\n      }\n    });\n\n    // Make a second pass and close the remaining dialogs. We do this second pass in order to\n    // correctly dispatch the `afterAllClosed` event in case we have a mixed array of dialogs\n    // that should be closed and dialogs that should not.\n    reverseForEach(this._openDialogsAtThisLevel, dialog => dialog.close());\n\n    this._afterAllClosedAtThisLevel.complete();\n    this._afterOpenedAtThisLevel.complete();\n    this._openDialogsAtThisLevel = [];\n  }\n\n  /**\n   * Creates an overlay config from a dialog config.\n   * @param config The dialog configuration.\n   * @returns The overlay configuration.\n   */\n  private _getOverlayConfig<D, R>(config: DialogConfig<D, R>): OverlayConfig {\n    const state = new OverlayConfig({\n      positionStrategy:\n        config.positionStrategy ||\n        this._overlay.position().global().centerHorizontally().centerVertically(),\n      scrollStrategy: config.scrollStrategy || this._scrollStrategy(),\n      panelClass: config.panelClass,\n      hasBackdrop: config.hasBackdrop,\n      direction: config.direction,\n      minWidth: config.minWidth,\n      minHeight: config.minHeight,\n      maxWidth: config.maxWidth,\n      maxHeight: config.maxHeight,\n      width: config.width,\n      height: config.height,\n      disposeOnNavigation: config.closeOnNavigation,\n    });\n\n    if (config.backdropClass) {\n      state.backdropClass = config.backdropClass;\n    }\n\n    return state;\n  }\n\n  /**\n   * Attaches a dialog container to a dialog's already-created overlay.\n   * @param overlay Reference to the dialog's underlying overlay.\n   * @param config The dialog configuration.\n   * @returns A promise resolving to a ComponentRef for the attached container.\n   */\n  private _attachContainer<R, D, C>(\n    overlay: OverlayRef,\n    dialogRef: DialogRef<R, C>,\n    config: DialogConfig<D, DialogRef<R, C>>,\n  ): BasePortalOutlet {\n    const userInjector = config.injector || config.viewContainerRef?.injector;\n    const providers: StaticProvider[] = [\n      {provide: DialogConfig, useValue: config},\n      {provide: DialogRef, useValue: dialogRef},\n      {provide: OverlayRef, useValue: overlay},\n    ];\n    let containerType: Type<BasePortalOutlet>;\n\n    if (config.container) {\n      if (typeof config.container === 'function') {\n        containerType = config.container;\n      } else {\n        containerType = config.container.type;\n        providers.push(...config.container.providers(config));\n      }\n    } else {\n      containerType = CdkDialogContainer;\n    }\n\n    const containerPortal = new ComponentPortal(\n      containerType,\n      config.viewContainerRef,\n      Injector.create({parent: userInjector || this._injector, providers}),\n      config.componentFactoryResolver,\n    );\n    const containerRef = overlay.attach(containerPortal);\n\n    return containerRef.instance;\n  }\n\n  /**\n   * Attaches the user-provided component to the already-created dialog container.\n   * @param componentOrTemplateRef The type of component being loaded into the dialog,\n   *     or a TemplateRef to instantiate as the content.\n   * @param dialogRef Reference to the dialog being opened.\n   * @param dialogContainer Component that is going to wrap the dialog content.\n   * @param config Configuration used to open the dialog.\n   */\n  private _attachDialogContent<R, D, C>(\n    componentOrTemplateRef: ComponentType<C> | TemplateRef<C>,\n    dialogRef: DialogRef<R, C>,\n    dialogContainer: BasePortalOutlet,\n    config: DialogConfig<D, DialogRef<R, C>>,\n  ) {\n    if (componentOrTemplateRef instanceof TemplateRef) {\n      const injector = this._createInjector(config, dialogRef, dialogContainer, undefined);\n      let context: any = {$implicit: config.data, dialogRef};\n\n      if (config.templateContext) {\n        context = {\n          ...context,\n          ...(typeof config.templateContext === 'function'\n            ? config.templateContext()\n            : config.templateContext),\n        };\n      }\n\n      dialogContainer.attachTemplatePortal(\n        new TemplatePortal<C>(componentOrTemplateRef, null!, context, injector),\n      );\n    } else {\n      const injector = this._createInjector(config, dialogRef, dialogContainer, this._injector);\n      const contentRef = dialogContainer.attachComponentPortal<C>(\n        new ComponentPortal(\n          componentOrTemplateRef,\n          config.viewContainerRef,\n          injector,\n          config.componentFactoryResolver,\n        ),\n      );\n      (dialogRef as {componentRef: ComponentRef<C>}).componentRef = contentRef;\n      (dialogRef as {componentInstance: C}).componentInstance = contentRef.instance;\n    }\n  }\n\n  /**\n   * Creates a custom injector to be used inside the dialog. This allows a component loaded inside\n   * of a dialog to close itself and, optionally, to return a value.\n   * @param config Config object that is used to construct the dialog.\n   * @param dialogRef Reference to the dialog being opened.\n   * @param dialogContainer Component that is going to wrap the dialog content.\n   * @param fallbackInjector Injector to use as a fallback when a lookup fails in the custom\n   * dialog injector, if the user didn't provide a custom one.\n   * @returns The custom injector that can be used inside the dialog.\n   */\n  private _createInjector<R, D, C>(\n    config: DialogConfig<D, DialogRef<R, C>>,\n    dialogRef: DialogRef<R, C>,\n    dialogContainer: BasePortalOutlet,\n    fallbackInjector: Injector | undefined,\n  ): Injector {\n    const userInjector = config.injector || config.viewContainerRef?.injector;\n    const providers: StaticProvider[] = [\n      {provide: DIALOG_DATA, useValue: config.data},\n      {provide: DialogRef, useValue: dialogRef},\n    ];\n\n    if (config.providers) {\n      if (typeof config.providers === 'function') {\n        providers.push(...config.providers(dialogRef, config, dialogContainer));\n      } else {\n        providers.push(...config.providers);\n      }\n    }\n\n    if (\n      config.direction &&\n      (!userInjector ||\n        !userInjector.get<Directionality | null>(Directionality, null, {optional: true}))\n    ) {\n      providers.push({\n        provide: Directionality,\n        useValue: {value: config.direction, change: observableOf()},\n      });\n    }\n\n    return Injector.create({parent: userInjector || fallbackInjector, providers});\n  }\n\n  /**\n   * Removes a dialog from the array of open dialogs.\n   * @param dialogRef Dialog to be removed.\n   * @param emitEvent Whether to emit an event if this is the last dialog.\n   */\n  private _removeOpenDialog<R, C>(dialogRef: DialogRef<R, C>, emitEvent: boolean) {\n    const index = this.openDialogs.indexOf(dialogRef);\n\n    if (index > -1) {\n      (this.openDialogs as DialogRef<R, C>[]).splice(index, 1);\n\n      // If all the dialogs were closed, remove/restore the `aria-hidden`\n      // to a the siblings and emit to the `afterAllClosed` stream.\n      if (!this.openDialogs.length) {\n        this._ariaHiddenElements.forEach((previousValue, element) => {\n          if (previousValue) {\n            element.setAttribute('aria-hidden', previousValue);\n          } else {\n            element.removeAttribute('aria-hidden');\n          }\n        });\n\n        this._ariaHiddenElements.clear();\n\n        if (emitEvent) {\n          this._getAfterAllClosed().next();\n        }\n      }\n    }\n  }\n\n  /** Hides all of the content that isn't an overlay from assistive technology. */\n  private _hideNonDialogContentFromAssistiveTechnology() {\n    const overlayContainer = this._overlayContainer.getContainerElement();\n\n    // Ensure that the overlay container is attached to the DOM.\n    if (overlayContainer.parentElement) {\n      const siblings = overlayContainer.parentElement.children;\n\n      for (let i = siblings.length - 1; i > -1; i--) {\n        const sibling = siblings[i];\n\n        if (\n          sibling !== overlayContainer &&\n          sibling.nodeName !== 'SCRIPT' &&\n          sibling.nodeName !== 'STYLE' &&\n          !sibling.hasAttribute('aria-live')\n        ) {\n          this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));\n          sibling.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n  }\n\n  private _getAfterAllClosed(): Subject<void> {\n    const parent = this._parentDialog;\n    return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;\n  }\n}\n\n/**\n * Executes a callback against all elements in an array while iterating in reverse.\n * Useful if the array is being modified as it is being iterated.\n */\nfunction reverseForEach<T>(items: T[] | readonly T[], callback: (current: T) => void) {\n  let i = items.length;\n\n  while (i--) {\n    callback(items[i]);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {PortalModule} from '@angular/cdk/portal';\nimport {A11yModule} from '@angular/cdk/a11y';\nimport {Dialog} from './dialog';\nimport {CdkDialogContainer} from './dialog-container';\n\n@NgModule({\n  imports: [OverlayModule, PortalModule, A11yModule, CdkDialogContainer],\n  exports: [\n    // Re-export the PortalModule so that people extending the `CdkDialogContainer`\n    // don't have to remember to import it or be faced with an unhelpful error.\n    PortalModule,\n    CdkDialogContainer,\n  ],\n  providers: [Dialog],\n})\nexport class DialogModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewContainerRef, ComponentFactoryResolver, Injector} from '@angular/core';\nimport {Direction} from '@angular/cdk/bidi';\nimport {ScrollStrategy} from '@angular/cdk/overlay';\nimport {_defaultParams} from './dialog-animations';\n\n/** Options for where to set focus to automatically on dialog open */\nexport type AutoFocusTarget = 'dialog' | 'first-tabbable' | 'first-heading';\n\n/** Valid ARIA roles for a dialog element. */\nexport type DialogRole = 'dialog' | 'alertdialog';\n\n/** Possible overrides for a dialog's position. */\nexport interface DialogPosition {\n  /** Override for the dialog's top position. */\n  top?: string;\n\n  /** Override for the dialog's bottom position. */\n  bottom?: string;\n\n  /** Override for the dialog's left position. */\n  left?: string;\n\n  /** Override for the dialog's right position. */\n  right?: string;\n}\n\n/**\n * Configuration for opening a modal dialog with the MatDialog service.\n */\nexport class MatDialogConfig<D = any> {\n  /**\n   * Where the attached component should live in Angular's *logical* component tree.\n   * This affects what is available for injection and the change detection order for the\n   * component instantiated inside of the dialog. This does not affect where the dialog\n   * content will be rendered.\n   */\n  viewContainerRef?: ViewContainerRef;\n\n  /**\n   * Injector used for the instantiation of the component to be attached. If provided,\n   * takes precedence over the injector indirectly provided by `ViewContainerRef`.\n   */\n  injector?: Injector;\n\n  /** ID for the dialog. If omitted, a unique one will be generated. */\n  id?: string;\n\n  /** The ARIA role of the dialog element. */\n  role?: DialogRole = 'dialog';\n\n  /** Custom class for the overlay pane. */\n  panelClass?: string | string[] = '';\n\n  /** Whether the dialog has a backdrop. */\n  hasBackdrop?: boolean = true;\n\n  /** Custom class for the backdrop. */\n  backdropClass?: string | string[] = '';\n\n  /** Whether the user can use escape or clicking on the backdrop to close the modal. */\n  disableClose?: boolean = false;\n\n  /** Width of the dialog. */\n  width?: string = '';\n\n  /** Height of the dialog. */\n  height?: string = '';\n\n  /** Min-width of the dialog. If a number is provided, assumes pixel units. */\n  minWidth?: number | string;\n\n  /** Min-height of the dialog. If a number is provided, assumes pixel units. */\n  minHeight?: number | string;\n\n  /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */\n  maxWidth?: number | string = '80vw';\n\n  /** Max-height of the dialog. If a number is provided, assumes pixel units. */\n  maxHeight?: number | string;\n\n  /** Position overrides. */\n  position?: DialogPosition;\n\n  /** Data being injected into the child component. */\n  data?: D | null = null;\n\n  /** Layout direction for the dialog's content. */\n  direction?: Direction;\n\n  /** ID of the element that describes the dialog. */\n  ariaDescribedBy?: string | null = null;\n\n  /** ID of the element that labels the dialog. */\n  ariaLabelledBy?: string | null = null;\n\n  /** Aria label to assign to the dialog element. */\n  ariaLabel?: string | null = null;\n\n  /** Whether this is a modal dialog. Used to set the `aria-modal` attribute. */\n  ariaModal?: boolean = true;\n\n  /**\n   * Where the dialog should focus on open.\n   * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or\n   * AutoFocusTarget instead.\n   */\n  autoFocus?: AutoFocusTarget | string | boolean = 'first-tabbable';\n\n  /**\n   * Whether the dialog should restore focus to the\n   * previously-focused element, after it's closed.\n   */\n  restoreFocus?: boolean = true;\n\n  /** Whether to wait for the opening animation to finish before trapping focus. */\n  delayFocusTrap?: boolean = true;\n\n  /** Scroll strategy to be used for the dialog. */\n  scrollStrategy?: ScrollStrategy;\n\n  /**\n   * Whether the dialog should close when the user goes backwards/forwards in history.\n   * Note that this usually doesn't include clicking on links (unless the user is using\n   * the `HashLocationStrategy`).\n   */\n  closeOnNavigation?: boolean = true;\n\n  /** Alternate `ComponentFactoryResolver` to use when resolving the associated component. */\n  componentFactoryResolver?: ComponentFactoryResolver;\n\n  /**\n   * Duration of the enter animation in ms.\n   * Should be a number, string type is deprecated.\n   * @breaking-change 17.0.0 Remove string signature.\n   */\n  enterAnimationDuration?: string | number;\n\n  /**\n   * Duration of the exit animation in ms.\n   * Should be a number, string type is deprecated.\n   * @breaking-change 17.0.0 Remove string signature.\n   */\n  exitAnimationDuration?: string | number;\n\n  // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusMonitor, FocusTrapFactory, InteractivityChecker} from '@angular/cdk/a11y';\nimport {OverlayRef} from '@angular/cdk/overlay';\nimport {DOCUMENT} from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ComponentRef,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  NgZone,\n  OnDestroy,\n  Optional,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {MatDialogConfig} from './dialog-config';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {CdkDialogContainer} from '@angular/cdk/dialog';\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {ComponentPortal, PortalModule} from '@angular/cdk/portal';\n\n/** Event that captures the state of dialog container animations. */\ninterface LegacyDialogAnimationEvent {\n  state: 'opened' | 'opening' | 'closing' | 'closed';\n  totalTime: number;\n}\n\n/** Class added when the dialog is open. */\nconst OPEN_CLASS = 'mdc-dialog--open';\n\n/** Class added while the dialog is opening. */\nconst OPENING_CLASS = 'mdc-dialog--opening';\n\n/** Class added while the dialog is closing. */\nconst CLOSING_CLASS = 'mdc-dialog--closing';\n\n/** Duration of the opening animation in milliseconds. */\nexport const OPEN_ANIMATION_DURATION = 150;\n\n/** Duration of the closing animation in milliseconds. */\nexport const CLOSE_ANIMATION_DURATION = 75;\n\n@Component({\n  selector: 'mat-dialog-container',\n  templateUrl: 'dialog-container.html',\n  styleUrls: ['dialog.css'],\n  encapsulation: ViewEncapsulation.None,\n  // Disabled for consistency with the non-MDC dialog container.\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  standalone: true,\n  imports: [PortalModule],\n  host: {\n    'class': 'mat-mdc-dialog-container mdc-dialog',\n    'tabindex': '-1',\n    '[attr.aria-modal]': '_config.ariaModal',\n    '[id]': '_config.id',\n    '[attr.role]': '_config.role',\n    '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledByQueue[0]',\n    '[attr.aria-label]': '_config.ariaLabel',\n    '[attr.aria-describedby]': '_config.ariaDescribedBy || null',\n    '[class._mat-animation-noopable]': '!_animationsEnabled',\n  },\n})\nexport class MatDialogContainer extends CdkDialogContainer<MatDialogConfig> implements OnDestroy {\n  /** Emits when an animation state changes. */\n  _animationStateChanged = new EventEmitter<LegacyDialogAnimationEvent>();\n\n  /** Whether animations are enabled. */\n  _animationsEnabled: boolean = this._animationMode !== 'NoopAnimations';\n\n  /** Host element of the dialog container component. */\n  private _hostElement: HTMLElement = this._elementRef.nativeElement;\n  /** Duration of the dialog open animation. */\n  private _enterAnimationDuration = this._animationsEnabled\n    ? parseCssTime(this._config.enterAnimationDuration) ?? OPEN_ANIMATION_DURATION\n    : 0;\n  /** Duration of the dialog close animation. */\n  private _exitAnimationDuration = this._animationsEnabled\n    ? parseCssTime(this._config.exitAnimationDuration) ?? CLOSE_ANIMATION_DURATION\n    : 0;\n  /** Current timer for dialog animations. */\n  private _animationTimer: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    elementRef: ElementRef,\n    focusTrapFactory: FocusTrapFactory,\n    @Optional() @Inject(DOCUMENT) _document: any,\n    dialogConfig: MatDialogConfig,\n    interactivityChecker: InteractivityChecker,\n    ngZone: NgZone,\n    overlayRef: OverlayRef,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) private _animationMode?: string,\n    focusMonitor?: FocusMonitor,\n  ) {\n    super(\n      elementRef,\n      focusTrapFactory,\n      _document,\n      dialogConfig,\n      interactivityChecker,\n      ngZone,\n      overlayRef,\n      focusMonitor,\n    );\n  }\n\n  protected override _contentAttached(): void {\n    // Delegate to the original dialog-container initialization (i.e. saving the\n    // previous element, setting up the focus trap and moving focus to the container).\n    super._contentAttached();\n\n    // Note: Usually we would be able to use the MDC dialog foundation here to handle\n    // the dialog animation for us, but there are a few reasons why we just leverage\n    // their styles and not use the runtime foundation code:\n    //   1. Foundation does not allow us to disable animations.\n    //   2. Foundation contains unnecessary features we don't need and aren't\n    //      tree-shakeable. e.g. background scrim, keyboard event handlers for ESC button.\n    //   3. Foundation uses unnecessary timers for animations to work around limitations\n    //      in React's `setState` mechanism.\n    //      https://github.com/material-components/material-components-web/pull/3682.\n    this._startOpenAnimation();\n  }\n\n  /** Starts the dialog open animation if enabled. */\n  private _startOpenAnimation() {\n    this._animationStateChanged.emit({state: 'opening', totalTime: this._enterAnimationDuration});\n\n    if (this._animationsEnabled) {\n      this._hostElement.style.setProperty(\n        TRANSITION_DURATION_PROPERTY,\n        `${this._enterAnimationDuration}ms`,\n      );\n\n      // We need to give the `setProperty` call from above some time to be applied.\n      // One would expect that the open class is added once the animation finished, but MDC\n      // uses the open class in combination with the opening class to start the animation.\n      this._requestAnimationFrame(() => this._hostElement.classList.add(OPENING_CLASS, OPEN_CLASS));\n      this._waitForAnimationToComplete(this._enterAnimationDuration, this._finishDialogOpen);\n    } else {\n      this._hostElement.classList.add(OPEN_CLASS);\n      // Note: We could immediately finish the dialog opening here with noop animations,\n      // but we defer until next tick so that consumers can subscribe to `afterOpened`.\n      // Executing this immediately would mean that `afterOpened` emits synchronously\n      // on `dialog.open` before the consumer had a change to subscribe to `afterOpened`.\n      Promise.resolve().then(() => this._finishDialogOpen());\n    }\n  }\n\n  /**\n   * Starts the exit animation of the dialog if enabled. This method is\n   * called by the dialog ref.\n   */\n  _startExitAnimation(): void {\n    this._animationStateChanged.emit({state: 'closing', totalTime: this._exitAnimationDuration});\n    this._hostElement.classList.remove(OPEN_CLASS);\n\n    if (this._animationsEnabled) {\n      this._hostElement.style.setProperty(\n        TRANSITION_DURATION_PROPERTY,\n        `${this._exitAnimationDuration}ms`,\n      );\n\n      // We need to give the `setProperty` call from above some time to be applied.\n      this._requestAnimationFrame(() => this._hostElement.classList.add(CLOSING_CLASS));\n      this._waitForAnimationToComplete(this._exitAnimationDuration, this._finishDialogClose);\n    } else {\n      // This subscription to the `OverlayRef#backdropClick` observable in the `DialogRef` is\n      // set up before any user can subscribe to the backdrop click. The subscription triggers\n      // the dialog close and this method synchronously. If we'd synchronously emit the `CLOSED`\n      // animation state event if animations are disabled, the overlay would be disposed\n      // immediately and all other subscriptions to `DialogRef#backdropClick` would be silently\n      // skipped. We work around this by waiting with the dialog close until the next tick when\n      // all subscriptions have been fired as expected. This is not an ideal solution, but\n      // there doesn't seem to be any other good way. Alternatives that have been considered:\n      //   1. Deferring `DialogRef.close`. This could be a breaking change due to a new microtask.\n      //      Also this issue is specific to the MDC implementation where the dialog could\n      //      technically be closed synchronously. In the non-MDC one, Angular animations are used\n      //      and closing always takes at least a tick.\n      //   2. Ensuring that user subscriptions to `backdropClick`, `keydownEvents` in the dialog\n      //      ref are first. This would solve the issue, but has the risk of memory leaks and also\n      //      doesn't solve the case where consumers call `DialogRef.close` in their subscriptions.\n      // Based on the fact that this is specific to the MDC-based implementation of the dialog\n      // animations, the defer is applied here.\n      Promise.resolve().then(() => this._finishDialogClose());\n    }\n  }\n\n  /**\n   * Completes the dialog open by clearing potential animation classes, trapping\n   * focus and emitting an opened event.\n   */\n  private _finishDialogOpen = () => {\n    this._clearAnimationClasses();\n    this._openAnimationDone(this._enterAnimationDuration);\n  };\n\n  /**\n   * Completes the dialog close by clearing potential animation classes, restoring\n   * focus and emitting a closed event.\n   */\n  private _finishDialogClose = () => {\n    this._clearAnimationClasses();\n    this._animationStateChanged.emit({state: 'closed', totalTime: this._exitAnimationDuration});\n  };\n\n  /** Clears all dialog animation classes. */\n  private _clearAnimationClasses() {\n    this._hostElement.classList.remove(OPENING_CLASS, CLOSING_CLASS);\n  }\n\n  private _waitForAnimationToComplete(duration: number, callback: () => void) {\n    if (this._animationTimer !== null) {\n      clearTimeout(this._animationTimer);\n    }\n\n    // Note that we want this timer to run inside the NgZone, because we want\n    // the related events like `afterClosed` to be inside the zone as well.\n    this._animationTimer = setTimeout(callback, duration);\n  }\n\n  /** Runs a callback in `requestAnimationFrame`, if available. */\n  private _requestAnimationFrame(callback: () => void) {\n    this._ngZone.runOutsideAngular(() => {\n      if (typeof requestAnimationFrame === 'function') {\n        requestAnimationFrame(callback);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  protected override _captureInitialFocus(): void {\n    if (!this._config.delayFocusTrap) {\n      this._trapFocus();\n    }\n  }\n\n  /**\n   * Callback for when the open dialog animation has finished. Intended to\n   * be called by sub-classes that use different animation implementations.\n   */\n  protected _openAnimationDone(totalTime: number) {\n    if (this._config.delayFocusTrap) {\n      this._trapFocus();\n    }\n\n    this._animationStateChanged.next({state: 'opened', totalTime});\n  }\n\n  override ngOnDestroy() {\n    super.ngOnDestroy();\n\n    if (this._animationTimer !== null) {\n      clearTimeout(this._animationTimer);\n    }\n  }\n\n  override attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    // When a component is passed into the dialog, the host element interrupts\n    // the `display:flex` from affecting the dialog title, content, and\n    // actions. To fix this, we make the component host `display: contents` by\n    // marking its host with the `mat-mdc-dialog-component-host` class.\n    //\n    // Note that this problem does not exist when a template ref is used since\n    // the title, contents, and actions are then nested directly under the\n    // dialog surface.\n    const ref = super.attachComponentPortal(portal);\n    ref.location.nativeElement.classList.add('mat-mdc-dialog-component-host');\n    return ref;\n  }\n}\n\nconst TRANSITION_DURATION_PROPERTY = '--mat-dialog-transition-duration';\n\n// TODO(mmalerba): Remove this function after animation durations are required\n//  to be numbers.\n/**\n * Converts a CSS time string to a number in ms. If the given time is already a\n * number, it is assumed to be in ms.\n */\nfunction parseCssTime(time: string | number | undefined): number | null {\n  if (time == null) {\n    return null;\n  }\n  if (typeof time === 'number') {\n    return time;\n  }\n  if (time.endsWith('ms')) {\n    return coerceNumberProperty(time.substring(0, time.length - 2));\n  }\n  if (time.endsWith('s')) {\n    return coerceNumberProperty(time.substring(0, time.length - 1)) * 1000;\n  }\n  if (time === '0') {\n    return 0;\n  }\n  return null; // anything else is invalid.\n}\n", "<div class=\"mdc-dialog__container\">\n  <div class=\"mat-mdc-dialog-surface mdc-dialog__surface\">\n    <ng-template cdkPortalOutlet></ng-template>\n  </div>\n</div>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Possible states of the lifecycle of a dialog. */\nimport {FocusOrigin} from '@angular/cdk/a11y';\nimport {merge, Observable, Subject} from 'rxjs';\nimport {DialogRef} from '@angular/cdk/dialog';\nimport {DialogPosition, MatDialogConfig} from './dialog-config';\nimport {MatDialogContainer} from './dialog-container';\nimport {filter, take} from 'rxjs/operators';\nimport {ESCAPE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {GlobalPositionStrategy} from '@angular/cdk/overlay';\nimport {ComponentRef} from '@angular/core';\n\nexport const enum MatDialogState {\n  OPEN,\n  CLOSING,\n  CLOSED,\n}\n\n/**\n * Reference to a dialog opened via the MatDialog service.\n */\nexport class MatDialogRef<T, R = any> {\n  /** The instance of component opened into the dialog. */\n  componentInstance: T;\n\n  /**\n   * `ComponentRef` of the component opened into the dialog. Will be\n   * null when the dialog is opened using a `TemplateRef`.\n   */\n  readonly componentRef: ComponentRef<T> | null;\n\n  /** Whether the user is allowed to close the dialog. */\n  disableClose: boolean | undefined;\n\n  /** Unique ID for the dialog. */\n  id: string;\n\n  /** Subject for notifying the user that the dialog has finished opening. */\n  private readonly _afterOpened = new Subject<void>();\n\n  /** Subject for notifying the user that the dialog has started closing. */\n  private readonly _beforeClosed = new Subject<R | undefined>();\n\n  /** Result to be passed to afterClosed. */\n  private _result: R | undefined;\n\n  /** Handle to the timeout that's running as a fallback in case the exit animation doesn't fire. */\n  private _closeFallbackTimeout: number;\n\n  /** Current state of the dialog. */\n  private _state = MatDialogState.OPEN;\n\n  // TODO(crisbeto): we shouldn't have to declare this property, because `DialogRef.close`\n  // already has a second `options` parameter that we can use. The problem is that internal tests\n  // have assertions like `expect(MatDialogRef.close).toHaveBeenCalledWith(foo)` which will break,\n  // because it'll be called with two arguments by things like `MatDialogClose`.\n  /** Interaction that caused the dialog to close. */\n  private _closeInteractionType: FocusOrigin | undefined;\n\n  constructor(\n    private _ref: DialogRef<R, T>,\n    config: MatDialogConfig,\n    public _containerInstance: MatDialogContainer,\n  ) {\n    this.disableClose = config.disableClose;\n    this.id = _ref.id;\n\n    // Emit when opening animation completes\n    _containerInstance._animationStateChanged\n      .pipe(\n        filter(event => event.state === 'opened'),\n        take(1),\n      )\n      .subscribe(() => {\n        this._afterOpened.next();\n        this._afterOpened.complete();\n      });\n\n    // Dispose overlay when closing animation is complete\n    _containerInstance._animationStateChanged\n      .pipe(\n        filter(event => event.state === 'closed'),\n        take(1),\n      )\n      .subscribe(() => {\n        clearTimeout(this._closeFallbackTimeout);\n        this._finishDialogClose();\n      });\n\n    _ref.overlayRef.detachments().subscribe(() => {\n      this._beforeClosed.next(this._result);\n      this._beforeClosed.complete();\n      this._finishDialogClose();\n    });\n\n    merge(\n      this.backdropClick(),\n      this.keydownEvents().pipe(\n        filter(event => event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)),\n      ),\n    ).subscribe(event => {\n      if (!this.disableClose) {\n        event.preventDefault();\n        _closeDialogVia(this, event.type === 'keydown' ? 'keyboard' : 'mouse');\n      }\n    });\n  }\n\n  /**\n   * Close the dialog.\n   * @param dialogResult Optional result to return to the dialog opener.\n   */\n  close(dialogResult?: R): void {\n    this._result = dialogResult;\n\n    // Transition the backdrop in parallel to the dialog.\n    this._containerInstance._animationStateChanged\n      .pipe(\n        filter(event => event.state === 'closing'),\n        take(1),\n      )\n      .subscribe(event => {\n        this._beforeClosed.next(dialogResult);\n        this._beforeClosed.complete();\n        this._ref.overlayRef.detachBackdrop();\n\n        // The logic that disposes of the overlay depends on the exit animation completing, however\n        // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback\n        // timeout which will clean everything up if the animation hasn't fired within the specified\n        // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the\n        // vast majority of cases the timeout will have been cleared before it has the chance to fire.\n        this._closeFallbackTimeout = setTimeout(\n          () => this._finishDialogClose(),\n          event.totalTime + 100,\n        );\n      });\n\n    this._state = MatDialogState.CLOSING;\n    this._containerInstance._startExitAnimation();\n  }\n\n  /**\n   * Gets an observable that is notified when the dialog is finished opening.\n   */\n  afterOpened(): Observable<void> {\n    return this._afterOpened;\n  }\n\n  /**\n   * Gets an observable that is notified when the dialog is finished closing.\n   */\n  afterClosed(): Observable<R | undefined> {\n    return this._ref.closed;\n  }\n\n  /**\n   * Gets an observable that is notified when the dialog has started closing.\n   */\n  beforeClosed(): Observable<R | undefined> {\n    return this._beforeClosed;\n  }\n\n  /**\n   * Gets an observable that emits when the overlay's backdrop has been clicked.\n   */\n  backdropClick(): Observable<MouseEvent> {\n    return this._ref.backdropClick;\n  }\n\n  /**\n   * Gets an observable that emits when keydown events are targeted on the overlay.\n   */\n  keydownEvents(): Observable<KeyboardEvent> {\n    return this._ref.keydownEvents;\n  }\n\n  /**\n   * Updates the dialog's position.\n   * @param position New dialog position.\n   */\n  updatePosition(position?: DialogPosition): this {\n    let strategy = this._ref.config.positionStrategy as GlobalPositionStrategy;\n\n    if (position && (position.left || position.right)) {\n      position.left ? strategy.left(position.left) : strategy.right(position.right);\n    } else {\n      strategy.centerHorizontally();\n    }\n\n    if (position && (position.top || position.bottom)) {\n      position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);\n    } else {\n      strategy.centerVertically();\n    }\n\n    this._ref.updatePosition();\n\n    return this;\n  }\n\n  /**\n   * Updates the dialog's width and height.\n   * @param width New width of the dialog.\n   * @param height New height of the dialog.\n   */\n  updateSize(width: string = '', height: string = ''): this {\n    this._ref.updateSize(width, height);\n    return this;\n  }\n\n  /** Add a CSS class or an array of classes to the overlay pane. */\n  addPanelClass(classes: string | string[]): this {\n    this._ref.addPanelClass(classes);\n    return this;\n  }\n\n  /** Remove a CSS class or an array of classes from the overlay pane. */\n  removePanelClass(classes: string | string[]): this {\n    this._ref.removePanelClass(classes);\n    return this;\n  }\n\n  /** Gets the current state of the dialog's lifecycle. */\n  getState(): MatDialogState {\n    return this._state;\n  }\n\n  /**\n   * Finishes the dialog close by updating the state of the dialog\n   * and disposing the overlay.\n   */\n  private _finishDialogClose() {\n    this._state = MatDialogState.CLOSED;\n    this._ref.close(this._result, {focusOrigin: this._closeInteractionType});\n    this.componentInstance = null!;\n  }\n}\n\n/**\n * Closes the dialog with the specified interaction type. This is currently not part of\n * `MatDialogRef` as that would conflict with custom dialog ref mocks provided in tests.\n * More details. See: https://github.com/angular/components/pull/9257#issuecomment-651342226.\n */\n// TODO: Move this back into `MatDialogRef` when we provide an official mock dialog ref.\nexport function _closeDialogVia<R>(ref: MatDialogRef<R>, interactionType: FocusOrigin, result?: R) {\n  (ref as unknown as {_closeInteractionType: FocusOrigin})._closeInteractionType = interactionType;\n  return ref.close(result);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentType, Overlay, OverlayContainer, ScrollStrategy} from '@angular/cdk/overlay';\nimport {Location} from '@angular/common';\nimport {\n  ANIMATION_MODULE_TYPE,\n  ComponentRef,\n  Inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  OnDestroy,\n  Optional,\n  SkipSelf,\n  TemplateRef,\n  Type,\n  inject,\n} from '@angular/core';\nimport {MatDialogConfig} from './dialog-config';\nimport {MatDialogContainer} from './dialog-container';\nimport {MatDialogRef} from './dialog-ref';\nimport {defer, Observable, Subject} from 'rxjs';\nimport {Dialog, DialogConfig} from '@angular/cdk/dialog';\nimport {startWith} from 'rxjs/operators';\n\n/** Injection token that can be used to access the data that was passed in to a dialog. */\nexport const MAT_DIALOG_DATA = new InjectionToken<any>('MatMdcDialogData');\n\n/** Injection token that can be used to specify default dialog options. */\nexport const MAT_DIALOG_DEFAULT_OPTIONS = new InjectionToken<MatDialogConfig>(\n  'mat-mdc-dialog-default-options',\n);\n\n/** Injection token that determines the scroll handling while the dialog is open. */\nexport const MAT_DIALOG_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-mdc-dialog-scroll-strategy',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const overlay = inject(Overlay);\n      return () => overlay.scrollStrategies.block();\n    },\n  },\n);\n\n/**\n * @docs-private\n * @deprecated No longer used. To be removed.\n * @breaking-change 19.0.0\n */\nexport function MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(\n  overlay: Overlay,\n): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.block();\n}\n\n/**\n * @docs-private\n * @deprecated No longer used. To be removed.\n * @breaking-change 19.0.0\n */\nexport const MAT_DIALOG_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_DIALOG_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\n// Counter for unique dialog ids.\nlet uniqueId = 0;\n\n/**\n * Service to open Material Design modal dialogs.\n */\n@Injectable({providedIn: 'root'})\nexport class MatDialog implements OnDestroy {\n  private readonly _openDialogsAtThisLevel: MatDialogRef<any>[] = [];\n  private readonly _afterAllClosedAtThisLevel = new Subject<void>();\n  private readonly _afterOpenedAtThisLevel = new Subject<MatDialogRef<any>>();\n  protected _dialog: Dialog;\n  protected dialogConfigClass = MatDialogConfig;\n\n  private readonly _dialogRefConstructor: Type<MatDialogRef<any>>;\n  private readonly _dialogContainerType: Type<MatDialogContainer>;\n  private readonly _dialogDataToken: InjectionToken<any>;\n\n  /** Keeps track of the currently-open dialogs. */\n  get openDialogs(): MatDialogRef<any>[] {\n    return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\n  }\n\n  /** Stream that emits when a dialog has been opened. */\n  get afterOpened(): Subject<MatDialogRef<any>> {\n    return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\n  }\n\n  private _getAfterAllClosed(): Subject<void> {\n    const parent = this._parentDialog;\n    return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;\n  }\n\n  /**\n   * Stream that emits when all open dialog have finished closing.\n   * Will emit on subscribe if there are no open dialogs to begin with.\n   */\n  readonly afterAllClosed: Observable<void> = defer(() =>\n    this.openDialogs.length\n      ? this._getAfterAllClosed()\n      : this._getAfterAllClosed().pipe(startWith(undefined)),\n  ) as Observable<any>;\n\n  constructor(\n    private _overlay: Overlay,\n    injector: Injector,\n    /**\n     * @deprecated `_location` parameter to be removed.\n     * @breaking-change 10.0.0\n     */\n    @Optional() location: Location,\n    @Optional() @Inject(MAT_DIALOG_DEFAULT_OPTIONS) private _defaultOptions: MatDialogConfig,\n    @Inject(MAT_DIALOG_SCROLL_STRATEGY) private _scrollStrategy: any,\n    @Optional() @SkipSelf() private _parentDialog: MatDialog,\n    /**\n     * @deprecated No longer used. To be removed.\n     * @breaking-change 15.0.0\n     */\n    _overlayContainer: OverlayContainer,\n    /**\n     * @deprecated No longer used. To be removed.\n     * @breaking-change 14.0.0\n     */\n    @Optional()\n    @Inject(ANIMATION_MODULE_TYPE)\n    _animationMode?: 'NoopAnimations' | 'BrowserAnimations',\n  ) {\n    this._dialog = injector.get(Dialog);\n\n    this._dialogRefConstructor = MatDialogRef;\n    this._dialogContainerType = MatDialogContainer;\n    this._dialogDataToken = MAT_DIALOG_DATA;\n  }\n\n  /**\n   * Opens a modal dialog containing the given component.\n   * @param component Type of the component to load into the dialog.\n   * @param config Extra configuration options.\n   * @returns Reference to the newly-opened dialog.\n   */\n  open<T, D = any, R = any>(\n    component: ComponentType<T>,\n    config?: MatDialogConfig<D>,\n  ): MatDialogRef<T, R>;\n\n  /**\n   * Opens a modal dialog containing the given template.\n   * @param template TemplateRef to instantiate as the dialog content.\n   * @param config Extra configuration options.\n   * @returns Reference to the newly-opened dialog.\n   */\n  open<T, D = any, R = any>(\n    template: TemplateRef<T>,\n    config?: MatDialogConfig<D>,\n  ): MatDialogRef<T, R>;\n\n  open<T, D = any, R = any>(\n    template: ComponentType<T> | TemplateRef<T>,\n    config?: MatDialogConfig<D>,\n  ): MatDialogRef<T, R>;\n\n  open<T, D = any, R = any>(\n    componentOrTemplateRef: ComponentType<T> | TemplateRef<T>,\n    config?: MatDialogConfig<D>,\n  ): MatDialogRef<T, R> {\n    let dialogRef: MatDialogRef<T, R>;\n    config = {...(this._defaultOptions || new MatDialogConfig()), ...config};\n    config.id = config.id || `mat-mdc-dialog-${uniqueId++}`;\n    config.scrollStrategy = config.scrollStrategy || this._scrollStrategy();\n\n    const cdkRef = this._dialog.open<R, D, T>(componentOrTemplateRef, {\n      ...config,\n      positionStrategy: this._overlay.position().global().centerHorizontally().centerVertically(),\n      // Disable closing since we need to sync it up to the animation ourselves.\n      disableClose: true,\n      // Disable closing on destroy, because this service cleans up its open dialogs as well.\n      // We want to do the cleanup here, rather than the CDK service, because the CDK destroys\n      // the dialogs immediately whereas we want it to wait for the animations to finish.\n      closeOnDestroy: false,\n      // Disable closing on detachments so that we can sync up the animation.\n      // The Material dialog ref handles this manually.\n      closeOnOverlayDetachments: false,\n      container: {\n        type: this._dialogContainerType,\n        providers: () => [\n          // Provide our config as the CDK config as well since it has the same interface as the\n          // CDK one, but it contains the actual values passed in by the user for things like\n          // `disableClose` which we disable for the CDK dialog since we handle it ourselves.\n          {provide: this.dialogConfigClass, useValue: config},\n          {provide: DialogConfig, useValue: config},\n        ],\n      },\n      templateContext: () => ({dialogRef}),\n      providers: (ref, cdkConfig, dialogContainer) => {\n        dialogRef = new this._dialogRefConstructor(ref, config, dialogContainer);\n        dialogRef.updatePosition(config?.position);\n        return [\n          {provide: this._dialogContainerType, useValue: dialogContainer},\n          {provide: this._dialogDataToken, useValue: cdkConfig.data},\n          {provide: this._dialogRefConstructor, useValue: dialogRef},\n        ];\n      },\n    });\n\n    // This can't be assigned in the `providers` callback, because\n    // the instance hasn't been assigned to the CDK ref yet.\n    (dialogRef! as {componentRef: ComponentRef<T>}).componentRef = cdkRef.componentRef!;\n    dialogRef!.componentInstance = cdkRef.componentInstance!;\n\n    this.openDialogs.push(dialogRef!);\n    this.afterOpened.next(dialogRef!);\n\n    dialogRef!.afterClosed().subscribe(() => {\n      const index = this.openDialogs.indexOf(dialogRef);\n\n      if (index > -1) {\n        this.openDialogs.splice(index, 1);\n\n        if (!this.openDialogs.length) {\n          this._getAfterAllClosed().next();\n        }\n      }\n    });\n\n    return dialogRef!;\n  }\n\n  /**\n   * Closes all of the currently-open dialogs.\n   */\n  closeAll(): void {\n    this._closeDialogs(this.openDialogs);\n  }\n\n  /**\n   * Finds an open dialog by its id.\n   * @param id ID to use when looking up the dialog.\n   */\n  getDialogById(id: string): MatDialogRef<any> | undefined {\n    return this.openDialogs.find(dialog => dialog.id === id);\n  }\n\n  ngOnDestroy() {\n    // Only close the dialogs at this level on destroy\n    // since the parent service may still be active.\n    this._closeDialogs(this._openDialogsAtThisLevel);\n    this._afterAllClosedAtThisLevel.complete();\n    this._afterOpenedAtThisLevel.complete();\n  }\n\n  private _closeDialogs(dialogs: MatDialogRef<any>[]) {\n    let i = dialogs.length;\n\n    while (i--) {\n      dialogs[i].close();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Directive,\n  ElementRef,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  SimpleChanges,\n} from '@angular/core';\n\nimport {MatDialog} from './dialog';\nimport {_closeDialogVia, MatDialogRef} from './dialog-ref';\n\n/** Counter used to generate unique IDs for dialog elements. */\nlet dialogElementUid = 0;\n\n/**\n * Button that will close the current dialog.\n */\n@Directive({\n  selector: '[mat-dialog-close], [matDialogClose]',\n  exportAs: 'matDialogClose',\n  standalone: true,\n  host: {\n    '(click)': '_onButtonClick($event)',\n    '[attr.aria-label]': 'ariaLabel || null',\n    '[attr.type]': 'type',\n  },\n})\nexport class MatDialogClose implements OnInit, OnChanges {\n  /** Screen-reader label for the button. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** Default to \"button\" to prevents accidental form submits. */\n  @Input() type: 'submit' | 'button' | 'reset' = 'button';\n\n  /** Dialog close input. */\n  @Input('mat-dialog-close') dialogResult: any;\n\n  @Input('matDialogClose') _matDialogClose: any;\n\n  constructor(\n    // The dialog title directive is always used in combination with a `MatDialogRef`.\n    // tslint:disable-next-line: lightweight-tokens\n    @Optional() public dialogRef: MatDialogRef<any>,\n    private _elementRef: ElementRef<HTMLElement>,\n    private _dialog: MatDialog,\n  ) {}\n\n  ngOnInit() {\n    if (!this.dialogRef) {\n      // When this directive is included in a dialog via TemplateRef (rather than being\n      // in a Component), the DialogRef isn't available via injection because embedded\n      // views cannot be given a custom injector. Instead, we look up the DialogRef by\n      // ID. This must occur in `onInit`, as the ID binding for the dialog container won't\n      // be resolved at constructor time.\n      this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs)!;\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];\n\n    if (proxiedChange) {\n      this.dialogResult = proxiedChange.currentValue;\n    }\n  }\n\n  _onButtonClick(event: MouseEvent) {\n    // Determinate the focus origin using the click event, because using the FocusMonitor will\n    // result in incorrect origins. Most of the time, close buttons will be auto focused in the\n    // dialog, and therefore clicking the button won't result in a focus change. This means that\n    // the FocusMonitor won't detect any origin change, and will always output `program`.\n    _closeDialogVia(\n      this.dialogRef,\n      event.screenX === 0 && event.screenY === 0 ? 'keyboard' : 'mouse',\n      this.dialogResult,\n    );\n  }\n}\n\n/**\n * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.\n */\n@Directive({\n  selector: '[mat-dialog-title], [matDialogTitle]',\n  exportAs: 'matDialogTitle',\n  standalone: true,\n  host: {\n    'class': 'mat-mdc-dialog-title mdc-dialog__title',\n    '[id]': 'id',\n  },\n})\nexport class MatDialogTitle implements OnInit, OnDestroy {\n  @Input() id: string = `mat-mdc-dialog-title-${dialogElementUid++}`;\n\n  constructor(\n    // The dialog title directive is always used in combination with a `MatDialogRef`.\n    // tslint:disable-next-line: lightweight-tokens\n    @Optional() private _dialogRef: MatDialogRef<any>,\n    private _elementRef: ElementRef<HTMLElement>,\n    private _dialog: MatDialog,\n  ) {}\n\n  ngOnInit() {\n    if (!this._dialogRef) {\n      this._dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs)!;\n    }\n\n    if (this._dialogRef) {\n      Promise.resolve().then(() => {\n        // Note: we null check the queue, because there are some internal\n        // tests that are mocking out `MatDialogRef` incorrectly.\n        this._dialogRef._containerInstance?._ariaLabelledByQueue?.push(this.id);\n      });\n    }\n  }\n\n  ngOnDestroy() {\n    // Note: we null check the queue, because there are some internal\n    // tests that are mocking out `MatDialogRef` incorrectly.\n    const queue = this._dialogRef?._containerInstance?._ariaLabelledByQueue;\n\n    if (queue) {\n      Promise.resolve().then(() => {\n        const index = queue.indexOf(this.id);\n\n        if (index > -1) {\n          queue.splice(index, 1);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Scrollable content container of a dialog.\n */\n@Directive({\n  selector: `[mat-dialog-content], mat-dialog-content, [matDialogContent]`,\n  host: {'class': 'mat-mdc-dialog-content mdc-dialog__content'},\n  standalone: true,\n})\nexport class MatDialogContent {}\n\n/**\n * Container for the bottom action buttons in a dialog.\n * Stays fixed to the bottom when scrolling.\n */\n@Directive({\n  selector: `[mat-dialog-actions], mat-dialog-actions, [matDialogActions]`,\n  standalone: true,\n  host: {\n    'class': 'mat-mdc-dialog-actions mdc-dialog__actions',\n    '[class.mat-mdc-dialog-actions-align-center]': 'align === \"center\"',\n    '[class.mat-mdc-dialog-actions-align-end]': 'align === \"end\"',\n  },\n})\nexport class MatDialogActions {\n  /**\n   * Horizontal alignment of action buttons.\n   */\n  @Input() align?: 'start' | 'center' | 'end' = 'start';\n}\n\n/**\n * Finds the closest MatDialogRef to an element by looking at the DOM.\n * @param element Element relative to which to look for a dialog.\n * @param openDialogs References to the currently-open dialogs.\n */\nfunction getClosestDialog(element: ElementRef<HTMLElement>, openDialogs: MatDialogRef<any>[]) {\n  let parent: HTMLElement | null = element.nativeElement.parentElement;\n\n  while (parent && !parent.classList.contains('mat-mdc-dialog-container')) {\n    parent = parent.parentElement;\n  }\n\n  return parent ? openDialogs.find(dialog => dialog.id === parent!.id) : null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DialogModule} from '@angular/cdk/dialog';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {PortalModule} from '@angular/cdk/portal';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '@angular/material/core';\nimport {MatDialog} from './dialog';\nimport {MatDialogContainer} from './dialog-container';\nimport {\n  MatDialogActions,\n  MatDialogClose,\n  MatDialogContent,\n  MatDialogTitle,\n} from './dialog-content-directives';\n\nconst DIRECTIVES = [\n  MatDialogContainer,\n  MatDialogClose,\n  MatDialogTitle,\n  MatDialogActions,\n  MatDialogContent,\n];\n\n@NgModule({\n  imports: [DialogModule, OverlayModule, PortalModule, MatCommonModule, ...DIRECTIVES],\n  exports: [MatCommonModule, ...DIRECTIVES],\n  providers: [MatDialog],\n})\nexport class MatDialogModule {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  animate,\n  state,\n  style,\n  transition,\n  trigger,\n  AnimationTriggerMetadata,\n  query,\n  animateChild,\n  group,\n} from '@angular/animations';\n\n/**\n * Default parameters for the animation for backwards compatibility.\n * @docs-private\n */\nexport const _defaultParams = {\n  params: {enterAnimationDuration: '150ms', exitAnimationDuration: '75ms'},\n};\n\n/**\n * Animations used by MatDialog.\n * @docs-private\n */\nexport const matDialogAnimations: {\n  readonly dialogContainer: AnimationTriggerMetadata;\n} = {\n  /** Animation that is applied on the dialog container by default. */\n  dialogContainer: trigger('dialogContainer', [\n    // Note: The `enter` animation transitions to `transform: none`, because for some reason\n    // specifying the transform explicitly, causes IE both to blur the dialog content and\n    // decimate the animation performance. Leaving it as `none` solves both issues.\n    state('void, exit', style({opacity: 0, transform: 'scale(0.7)'})),\n    state('enter', style({transform: 'none'})),\n    transition(\n      '* => enter',\n      group([\n        animate(\n          '{{enterAnimationDuration}} cubic-bezier(0, 0, 0.2, 1)',\n          style({transform: 'none', opacity: 1}),\n        ),\n        query('@*', animateChild(), {optional: true}),\n      ]),\n      _defaultParams,\n    ),\n    transition(\n      '* => void, * => exit',\n      group([\n        animate('{{exitAnimationDuration}} cubic-bezier(0.4, 0.0, 0.2, 1)', style({opacity: 0})),\n        query('@*', animateChild(), {optional: true}),\n      ]),\n      _defaultParams,\n    ),\n  ]),\n};\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["CdkDialogContainer_ng_template_0_Template", "rf", "ctx", "DialogConfig", "constructor", "role", "panelClass", "hasBackdrop", "backdropClass", "disableClose", "width", "height", "data", "ariaDescribedBy", "ariaLabelledBy", "ariaLabel", "ariaModal", "autoFocus", "restoreFocus", "closeOnNavigation", "closeOnDestroy", "closeOnOverlayDetachments", "throwDialogContentAlreadyAttachedError", "Error", "CdkDialogContainer", "BasePortalOutlet", "_elementRef", "_focusTrapFactory", "_document", "_config", "_interactivityChecker", "_ngZone", "_overlayRef", "_focusMonitor", "_elementFocusedBeforeDialogWasOpened", "_closeInteractionType", "_ariaLabelledByQueue", "attachDomPortal", "portal", "_portalOutlet", "hasAttached", "ngDevMode", "result", "_contentAttached", "push", "_initializeFocusTrap", "_handleBackdropClicks", "_captureInitialFocus", "_trapFocus", "ngOnDestroy", "_restoreFocus", "attachComponentPortal", "attachTemplatePortal", "_recaptureFocus", "_containsFocus", "_forceFocus", "element", "options", "isFocusable", "tabIndex", "runOutsideAngular", "callback", "removeEventListener", "removeAttribute", "addEventListener", "focus", "_focusByCssSelector", "selector", "elementToFocus", "nativeElement", "querySelector", "_focusTrap", "focusInitialElementWhenReady", "then", "focusedSuccessfully", "_focusDialogContainer", "focusConfig", "focusTargetElement", "activeElement", "_getFocusedElementPierceShadowDom", "body", "contains", "focusVia", "destroy", "create", "backdropClick", "subscribe", "ElementRef", "FocusTrapFactory", "DOCUMENT", "InteractivityChecker", "NgZone", "OverlayRef", "FocusMonitor", "ɵcmp", "selectors", "viewQuery", "CdkDialogContainer_Query", "CdkPortalOutlet", "_t", "hostVars", "hostBindings", "CdkDialogContainer_HostBindings", "dependencies", "PortalModule", "styles", "encapsulation", "Component", "args", "ViewEncapsulation", "None", "changeDetection", "ChangeDetectionStrategy", "Default", "standalone", "imports", "host", "template", "Optional", "Inject", "ViewChild", "static", "DialogRef", "overlayRef", "config", "closed", "Subject", "keydownEvents", "outsidePointerEvents", "id", "event", "keyCode", "ESCAPE", "hasModifierKey", "preventDefault", "close", "undefined", "focusOrigin", "_detachSubscription", "detachments", "containerInstance", "closedSubject", "unsubscribe", "dispose", "next", "complete", "componentInstance", "updatePosition", "updateSize", "addPanelClass", "classes", "removePanelClass", "DIALOG_SCROLL_STRATEGY", "InjectionToken", "providedIn", "factory", "overlay", "inject", "Overlay", "scrollStrategies", "block", "DIALOG_DATA", "DEFAULT_DIALOG_CONFIG", "uniqueId", "Dialog", "openDialogs", "_parentDialog", "_openDialogsAtThisLevel", "afterOpened", "_afterOpenedAtThisLevel", "constructor", "_overlay", "_injector", "_defaultOptions", "_overlayContainer", "scrollStrategy", "_afterAllClosedAtThisLevel", "Subject", "_ariaHiddenElements", "Map", "afterAllClosed", "defer", "length", "_getAfterAllClosed", "pipe", "startWith", "undefined", "_scrollStrategy", "open", "componentOrTemplateRef", "config", "defaults", "DialogConfig", "id", "getDialogById", "ngDevMode", "Error", "overlayConfig", "_getOverlayConfig", "overlayRef", "create", "dialogRef", "DialogRef", "dialogContainer", "_attachContainer", "containerInstance", "_attachDialogContent", "_hideNonDialogContentFromAssistiveTechnology", "push", "closed", "subscribe", "_removeOpenDialog", "next", "closeAll", "reverseForEach", "dialog", "close", "find", "ngOnDestroy", "closeOnDestroy", "complete", "state", "OverlayConfig", "positionStrategy", "position", "global", "centerHorizontally", "centerVertically", "panelClass", "hasBackdrop", "direction", "minWidth", "minHeight", "maxWidth", "maxHeight", "width", "height", "disposeOnNavigation", "closeOnNavigation", "backdropClass", "overlay", "userInjector", "injector", "viewContainerRef", "providers", "provide", "useValue", "OverlayRef", "containerType", "container", "type", "CdkDialogContainer", "containerPortal", "ComponentPortal", "Injector", "parent", "componentFactoryResolver", "containerRef", "attach", "instance", "TemplateRef", "_createInjector", "context", "$implicit", "data", "templateContext", "attachTemplatePortal", "TemplatePortal", "contentRef", "attachComponentPortal", "componentRef", "componentInstance", "fallbackInjector", "DIALOG_DATA", "get", "Directionality", "optional", "value", "change", "of", "emitEvent", "index", "indexOf", "splice", "forEach", "previousValue", "element", "setAttribute", "removeAttribute", "clear", "overlayContainer", "getContainerElement", "parentElement", "siblings", "children", "i", "sibling", "nodeName", "hasAttribute", "set", "getAttribute", "Overlay", "DEFAULT_DIALOG_CONFIG", "OverlayContainer", "DIALOG_SCROLL_STRATEGY", "ɵprov", "factory", "ɵfac", "providedIn", "Injectable", "Optional", "Inject", "SkipSelf", "items", "callback", "DialogModule", "ɵmod", "imports", "OverlayModule", "PortalModule", "A11yModule", "exports", "NgModule", "args", "MatDialogContainer_ng_template_2_Template", "rf", "ctx", "MatDialogConfig", "constructor", "role", "panelClass", "hasBackdrop", "backdropClass", "disableClose", "width", "height", "maxWidth", "data", "ariaDescribedBy", "ariaLabelledBy", "ariaLabel", "ariaModal", "autoFocus", "restoreFocus", "delayFocusTrap", "closeOnNavigation", "OPEN_CLASS", "OPENING_CLASS", "CLOSING_CLASS", "OPEN_ANIMATION_DURATION", "CLOSE_ANIMATION_DURATION", "MatDialogContainer", "CdkDialogContainer", "elementRef", "focusTrapFactory", "_document", "dialogConfig", "interactivityChecker", "ngZone", "overlayRef", "_animationMode", "focusMonitor", "_animationStateChanged", "EventEmitter", "_animationsEnabled", "_hostElement", "_elementRef", "nativeElement", "_enterAnimationDuration", "parseCssTime", "_config", "enterAnimationDuration", "_exitAnimationDuration", "exitAnimationDuration", "_animationTimer", "_finishDialogOpen", "_clearAnimationClasses", "_openAnimationDone", "_finishDialogClose", "emit", "state", "totalTime", "_contentAttached", "_startOpenAnimation", "style", "setProperty", "TRANSITION_DURATION_PROPERTY", "_requestAnimationFrame", "classList", "add", "_waitForAnimationToComplete", "Promise", "resolve", "then", "_startExitAnimation", "remove", "duration", "callback", "clearTimeout", "setTimeout", "_ngZone", "runOutsideAngular", "requestAnimationFrame", "_captureInitialFocus", "_trapFocus", "next", "ngOnDestroy", "attachComponentPortal", "portal", "ref", "location", "ElementRef", "FocusTrapFactory", "DOCUMENT", "InteractivityChecker", "NgZone", "OverlayRef", "ANIMATION_MODULE_TYPE", "FocusMonitor", "selectors", "hostAttrs", "hostVars", "hostBindings", "MatDialogContainer_HostBindings", "dependencies", "PortalModule", "CdkPortalOutlet", "styles", "encapsulation", "Component", "args", "selector", "ViewEncapsulation", "None", "changeDetection", "ChangeDetectionStrategy", "Default", "standalone", "imports", "host", "template", "Optional", "Inject", "time", "endsWith", "coerceNumberProperty", "substring", "length", "MatDialogRef", "_ref", "config", "_containerInstance", "_afterOpened", "Subject", "_beforeClosed", "_state", "id", "pipe", "filter", "event", "take", "subscribe", "complete", "_closeFallbackTimeout", "detachments", "_result", "merge", "backdropClick", "keydownEvents", "keyCode", "ESCAPE", "hasModifierKey", "preventDefault", "_closeDialogVia", "type", "close", "dialogResult", "detachBackdrop", "afterOpened", "afterClosed", "closed", "beforeClosed", "updatePosition", "position", "strategy", "positionStrategy", "left", "right", "centerHorizontally", "top", "bottom", "centerVertically", "updateSize", "addPanelClass", "classes", "removePanelClass", "getState", "focusOrigin", "_closeInteractionType", "componentInstance", "interactionType", "result", "MAT_DIALOG_DATA", "InjectionToken", "MAT_DIALOG_DEFAULT_OPTIONS", "MAT_DIALOG_SCROLL_STRATEGY", "providedIn", "factory", "overlay", "inject", "Overlay", "scrollStrategies", "block", "MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY", "MAT_DIALOG_SCROLL_STRATEGY_PROVIDER", "provide", "deps", "useFactory", "uniqueId", "MatDialog", "openDialogs", "_parentDialog", "_openDialogsAtThisLevel", "_afterOpenedAtThisLevel", "_getAfterAllClosed", "parent", "_afterAllClosedAtThisLevel", "_overlay", "injector", "_defaultOptions", "_scrollStrategy", "_overlayContainer", "dialogConfigClass", "afterAllClosed", "defer", "startWith", "undefined", "_dialog", "get", "Dialog", "_dialogRefConstructor", "_dialogContainerType", "_dialogDataToken", "open", "componentOrTemplateRef", "dialogRef", "scrollStrategy", "cdkRef", "global", "closeOnDestroy", "closeOnOverlayDetachments", "container", "providers", "useValue", "DialogConfig", "templateContext", "cdkConfig", "dialogContainer", "componentRef", "push", "index", "indexOf", "splice", "closeAll", "_closeDialogs", "getDialogById", "find", "dialog", "dialogs", "i", "ɵfac", "MatDialog_Factory", "t", "Injector", "Location", "OverlayContainer", "ANIMATION_MODULE_TYPE$1", "ɵprov", "Injectable", "SkipSelf", "dialogElementUid", "MatDialogClose", "ngOnInit", "getClosestDialog", "ngOnChanges", "changes", "proxiedChange", "currentValue", "_onButtonClick", "screenX", "screenY", "MatDialogClose_HostBindings", "$event", "Directive", "exportAs", "Input", "_matDialogClose", "MatDialogTitle", "_dialogRef", "_ariaLabelledByQueue", "queue", "MatDialogTitle_HostBindings", "MatDialogContent", "MatDialogActions", "align", "MatDialogActions_HostBindings", "element", "parentElement", "contains", "DIRECTIVES", "MatDialogModule", "DialogModule", "OverlayModule", "MatCommonModule", "exports", "ɵinj", "NgModule", "_defaultParams", "params", "matDialogAnimations", "trigger", "opacity", "transform", "transition", "group", "animate", "query", "animateChild", "optional"]
}
