{
  "version": 3,
  "sources": ["../../../../../../../src/material/autocomplete/animations.ts", "../../../../../../../src/material/autocomplete/autocomplete.ts", "../../../../../../../src/material/autocomplete/autocomplete.html", "../../../../../../../src/material/autocomplete/autocomplete-origin.ts", "../../../../../../../src/material/autocomplete/autocomplete-trigger.ts", "../../../../../../../src/material/autocomplete/module.ts", "../../../../../../../src/material/autocomplete/autocomplete_public_index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  animate,\n  AnimationTriggerMetadata,\n  group,\n  state,\n  style,\n  transition,\n  trigger,\n} from '@angular/animations';\n\n// Animation values come from\n// https://github.com/material-components/material-components-web/blob/master/packages/mdc-menu-surface/_mixins.scss\n// TODO(mmalerba): Ideally find a way to import the values from MDC's code.\nexport const panelAnimation: AnimationTriggerMetadata = trigger('panelAnimation', [\n  state(\n    'void, hidden',\n    style({\n      opacity: 0,\n      transform: 'scaleY(0.8)',\n    }),\n  ),\n  transition(':enter, hidden => visible', [\n    group([\n      animate('0.03s linear', style({opacity: 1})),\n      animate('0.12s cubic-bezier(0, 0, 0.2, 1)', style({transform: 'scaleY(1)'})),\n    ]),\n  ]),\n  transition(':leave, visible => hidden', [animate('0.075s linear', style({opacity: 0}))]),\n]);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  Output,\n  QueryList,\n  TemplateRef,\n  ViewChild,\n  ViewEncapsulation,\n  booleanAttribute,\n} from '@angular/core';\nimport {AnimationEvent} from '@angular/animations';\nimport {\n  MAT_OPTGROUP,\n  MAT_OPTION_PARENT_COMPONENT,\n  MatOptgroup,\n  MatOption,\n  ThemePalette,\n} from '@angular/material/core';\nimport {ActiveDescendantKeyManager} from '@angular/cdk/a11y';\nimport {coerceStringArray} from '@angular/cdk/coercion';\nimport {Platform} from '@angular/cdk/platform';\nimport {panelAnimation} from './animations';\nimport {Subscription} from 'rxjs';\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueAutocompleteIdCounter = 0;\n\n/** Event object that is emitted when an autocomplete option is selected. */\nexport class MatAutocompleteSelectedEvent {\n  constructor(\n    /** Reference to the autocomplete panel that emitted the event. */\n    public source: MatAutocomplete,\n    /** Option that was selected. */\n    public option: MatOption,\n  ) {}\n}\n\n/** Event object that is emitted when an autocomplete option is activated. */\nexport interface MatAutocompleteActivatedEvent {\n  /** Reference to the autocomplete panel that emitted the event. */\n  source: MatAutocomplete;\n\n  /** Option that was selected. */\n  option: MatOption | null;\n}\n\n/** Default `mat-autocomplete` options that can be overridden. */\nexport interface MatAutocompleteDefaultOptions {\n  /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n  autoActiveFirstOption?: boolean;\n\n  /** Whether the active option should be selected as the user is navigating. */\n  autoSelectActiveOption?: boolean;\n\n  /**\n   * Whether the user is required to make a selection when\n   * they're interacting with the autocomplete.\n   */\n  requireSelection?: boolean;\n\n  /** Class or list of classes to be applied to the autocomplete's overlay panel. */\n  overlayPanelClass?: string | string[];\n\n  /** Wheter icon indicators should be hidden for single-selection. */\n  hideSingleSelectionIndicator?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nexport const MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken<MatAutocompleteDefaultOptions>(\n  'mat-autocomplete-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\n/** @docs-private */\nexport function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY(): MatAutocompleteDefaultOptions {\n  return {\n    autoActiveFirstOption: false,\n    autoSelectActiveOption: false,\n    hideSingleSelectionIndicator: false,\n    requireSelection: false,\n  };\n}\n\n/** Autocomplete component. */\n@Component({\n  selector: 'mat-autocomplete',\n  templateUrl: 'autocomplete.html',\n  styleUrls: ['autocomplete.css'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  exportAs: 'matAutocomplete',\n  host: {\n    'class': 'mat-mdc-autocomplete',\n    'ngSkipHydration': '',\n  },\n  providers: [{provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete}],\n  animations: [panelAnimation],\n})\nexport class MatAutocomplete implements AfterContentInit, OnDestroy {\n  private _activeOptionChanges = Subscription.EMPTY;\n\n  /** Class to apply to the panel when it's visible. */\n  private _visibleClass = 'mat-mdc-autocomplete-visible';\n\n  /** Class to apply to the panel when it's hidden. */\n  private _hiddenClass = 'mat-mdc-autocomplete-hidden';\n\n  /** Emits when the panel animation is done. Null if the panel doesn't animate. */\n  _animationDone = new EventEmitter<AnimationEvent>();\n\n  /** Manages active item in option list based on key events. */\n  _keyManager: ActiveDescendantKeyManager<MatOption>;\n\n  /** Whether the autocomplete panel should be visible, depending on option length. */\n  showPanel: boolean = false;\n\n  /** Whether the autocomplete panel is open. */\n  get isOpen(): boolean {\n    return this._isOpen && this.showPanel;\n  }\n  _isOpen: boolean = false;\n\n  /** @docs-private Sets the theme color of the panel. */\n  _setColor(value: ThemePalette) {\n    this._color = value;\n    this._setThemeClasses(this._classList);\n  }\n  /** @docs-private theme color of the panel */\n  private _color: ThemePalette;\n\n  // The @ViewChild query for TemplateRef here needs to be static because some code paths\n  // lead to the overlay being created before change detection has finished for this component.\n  // Notably, another component may trigger `focus` on the autocomplete-trigger.\n\n  /** @docs-private */\n  @ViewChild(TemplateRef, {static: true}) template: TemplateRef<any>;\n\n  /** Element for the panel containing the autocomplete options. */\n  @ViewChild('panel') panel: ElementRef;\n\n  /** Reference to all options within the autocomplete. */\n  @ContentChildren(MatOption, {descendants: true}) options: QueryList<MatOption>;\n\n  /** Reference to all option groups within the autocomplete. */\n  @ContentChildren(MAT_OPTGROUP, {descendants: true}) optionGroups: QueryList<MatOptgroup>;\n\n  /** Aria label of the autocomplete. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** Input that can be used to specify the `aria-labelledby` attribute. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** Function that maps an option's control value to its display value in the trigger. */\n  @Input() displayWith: ((value: any) => string) | null = null;\n\n  /**\n   * Whether the first option should be highlighted when the autocomplete panel is opened.\n   * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n   */\n  @Input({transform: booleanAttribute}) autoActiveFirstOption: boolean;\n\n  /** Whether the active option should be selected as the user is navigating. */\n  @Input({transform: booleanAttribute}) autoSelectActiveOption: boolean;\n\n  /**\n   * Whether the user is required to make a selection when they're interacting with the\n   * autocomplete. If the user moves away from the autocomplete without selecting an option from\n   * the list, the value will be reset. If the user opens the panel and closes it without\n   * interacting or selecting a value, the initial value will be kept.\n   */\n  @Input({transform: booleanAttribute}) requireSelection: boolean;\n\n  /**\n   * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n   * match the width of its host.\n   */\n  @Input() panelWidth: string | number;\n\n  /** Whether ripples are disabled within the autocomplete panel. */\n  @Input({transform: booleanAttribute}) disableRipple: boolean;\n\n  /** Event that is emitted whenever an option from the list is selected. */\n  @Output() readonly optionSelected: EventEmitter<MatAutocompleteSelectedEvent> =\n    new EventEmitter<MatAutocompleteSelectedEvent>();\n\n  /** Event that is emitted when the autocomplete panel is opened. */\n  @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Event that is emitted when the autocomplete panel is closed. */\n  @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Emits whenever an option is activated. */\n  @Output() readonly optionActivated: EventEmitter<MatAutocompleteActivatedEvent> =\n    new EventEmitter<MatAutocompleteActivatedEvent>();\n\n  /**\n   * Takes classes set on the host mat-autocomplete element and applies them to the panel\n   * inside the overlay container to allow for easy styling.\n   */\n  @Input('class')\n  set classList(value: string | string[]) {\n    if (value && value.length) {\n      this._classList = coerceStringArray(value).reduce(\n        (classList, className) => {\n          classList[className] = true;\n          return classList;\n        },\n        {} as {[key: string]: boolean},\n      );\n    } else {\n      this._classList = {};\n    }\n\n    this._setVisibilityClasses(this._classList);\n    this._setThemeClasses(this._classList);\n    this._elementRef.nativeElement.className = '';\n  }\n  _classList: {[key: string]: boolean} = {};\n\n  /** Whether checkmark indicator for single-selection options is hidden. */\n  @Input({transform: booleanAttribute})\n  get hideSingleSelectionIndicator(): boolean {\n    return this._hideSingleSelectionIndicator;\n  }\n  set hideSingleSelectionIndicator(value: boolean) {\n    this._hideSingleSelectionIndicator = value;\n    this._syncParentProperties();\n  }\n  private _hideSingleSelectionIndicator: boolean;\n\n  /** Syncs the parent state with the individual options. */\n  _syncParentProperties(): void {\n    if (this.options) {\n      for (const option of this.options) {\n        option._changeDetectorRef.markForCheck();\n      }\n    }\n  }\n\n  /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n  id: string = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n\n  /**\n   * Tells any descendant `mat-optgroup` to use the inert a11y pattern.\n   * @docs-private\n   */\n  readonly inertGroups: boolean;\n\n  constructor(\n    private _changeDetectorRef: ChangeDetectorRef,\n    private _elementRef: ElementRef<HTMLElement>,\n    @Inject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS) protected _defaults: MatAutocompleteDefaultOptions,\n    platform?: Platform,\n  ) {\n    // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on\n    // Safari using VoiceOver. We should occasionally check back to see whether the bug\n    // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`\n    // option altogether.\n    this.inertGroups = platform?.SAFARI || false;\n    this.autoActiveFirstOption = !!_defaults.autoActiveFirstOption;\n    this.autoSelectActiveOption = !!_defaults.autoSelectActiveOption;\n    this.requireSelection = !!_defaults.requireSelection;\n    this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? false;\n  }\n\n  ngAfterContentInit() {\n    this._keyManager = new ActiveDescendantKeyManager<MatOption>(this.options)\n      .withWrap()\n      .skipPredicate(this._skipPredicate);\n    this._activeOptionChanges = this._keyManager.change.subscribe(index => {\n      if (this.isOpen) {\n        this.optionActivated.emit({source: this, option: this.options.toArray()[index] || null});\n      }\n    });\n\n    // Set the initial visibility state.\n    this._setVisibility();\n  }\n\n  ngOnDestroy() {\n    this._keyManager?.destroy();\n    this._activeOptionChanges.unsubscribe();\n    this._animationDone.complete();\n  }\n\n  /**\n   * Sets the panel scrollTop. This allows us to manually scroll to display options\n   * above or below the fold, as they are not actually being focused when active.\n   */\n  _setScrollTop(scrollTop: number): void {\n    if (this.panel) {\n      this.panel.nativeElement.scrollTop = scrollTop;\n    }\n  }\n\n  /** Returns the panel's scrollTop. */\n  _getScrollTop(): number {\n    return this.panel ? this.panel.nativeElement.scrollTop : 0;\n  }\n\n  /** Panel should hide itself when the option list is empty. */\n  _setVisibility() {\n    this.showPanel = !!this.options.length;\n    this._setVisibilityClasses(this._classList);\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Emits the `select` event. */\n  _emitSelectEvent(option: MatOption): void {\n    const event = new MatAutocompleteSelectedEvent(this, option);\n    this.optionSelected.emit(event);\n  }\n\n  /** Gets the aria-labelledby for the autocomplete panel. */\n  _getPanelAriaLabelledby(labelId: string | null): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelExpression = labelId ? labelId + ' ' : '';\n    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n  }\n\n  /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n  private _setVisibilityClasses(classList: {[key: string]: boolean}) {\n    classList[this._visibleClass] = this.showPanel;\n    classList[this._hiddenClass] = !this.showPanel;\n  }\n\n  /** Sets the theming classes on a classlist based on the theme of the panel. */\n  private _setThemeClasses(classList: {[key: string]: boolean}) {\n    classList['mat-primary'] = this._color === 'primary';\n    classList['mat-warn'] = this._color === 'warn';\n    classList['mat-accent'] = this._color === 'accent';\n  }\n\n  // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n  // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n  // recommendation.\n  //\n  // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n  // makes a few exceptions for compound widgets.\n  //\n  // From [Developing a Keyboard Interface](\n  // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n  //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n  //   Listbox...\"\n  //\n  // The user can focus disabled options using the keyboard, but the user cannot click disabled\n  // options.\n  protected _skipPredicate() {\n    return false;\n  }\n}\n", "<ng-template let-formFieldId=\"id\">\n  <div\n    class=\"mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open\"\n    role=\"listbox\"\n    [id]=\"id\"\n    [ngClass]=\"_classList\"\n    [attr.aria-label]=\"ariaLabel || null\"\n    [attr.aria-labelledby]=\"_getPanelAriaLabelledby(formFieldId)\"\n    [@panelAnimation]=\"isOpen ? 'visible' : 'hidden'\"\n    (@panelAnimation.done)=\"_animationDone.next($event)\"\n    #panel>\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef} from '@angular/core';\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n@Directive({\n  selector: '[matAutocompleteOrigin]',\n  exportAs: 'matAutocompleteOrigin',\n})\nexport class MatAutocompleteOrigin {\n  constructor(\n    /** Reference to the element on which the directive is applied. */\n    public elementRef: ElementRef<HTMLElement>,\n  ) {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {addAriaReferencedId, removeAriaReferencedId} from '@angular/cdk/a11y';\nimport {\n  AfterViewInit,\n  booleanAttribute,\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  forwardRef,\n  Host,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  SimpleChanges,\n  ViewContainerRef,\n} from '@angular/core';\nimport {DOCUMENT} from '@angular/common';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW, hasModifierKey} from '@angular/cdk/keycodes';\nimport {_getEventTarget} from '@angular/cdk/platform';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {\n  FlexibleConnectedPositionStrategy,\n  Overlay,\n  OverlayConfig,\n  OverlayRef,\n  PositionStrategy,\n  ScrollStrategy,\n  ConnectedPosition,\n} from '@angular/cdk/overlay';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  MatOptionSelectionChange,\n  _countGroupLabelsBeforeOption,\n  _getOptionScrollPosition,\n  MatOption,\n} from '@angular/material/core';\nimport {MAT_FORM_FIELD, MatFormField} from '@angular/material/form-field';\nimport {defer, fromEvent, merge, Observable, of as observableOf, Subject, Subscription} from 'rxjs';\nimport {delay, filter, map, switchMap, take, tap, startWith} from 'rxjs/operators';\nimport {MatAutocompleteOrigin} from './autocomplete-origin';\nimport {\n  MatAutocompleteDefaultOptions,\n  MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,\n  MatAutocomplete,\n} from './autocomplete';\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatAutocompleteTrigger),\n  multi: true,\n};\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport function getMatAutocompleteMissingPanelError(): Error {\n  return Error(\n    'Attempting to open an undefined instance of `mat-autocomplete`. ' +\n      'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n      \"you're attempting to open it after the ngAfterContentInit hook.\",\n  );\n}\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport const MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-autocomplete-scroll-strategy',\n);\n\n/** @docs-private */\nexport function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.reposition();\n}\n\n/** @docs-private */\nexport const MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n};\n\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\n@Directive({\n  selector: `input[matAutocomplete], textarea[matAutocomplete]`,\n  host: {\n    'class': 'mat-mdc-autocomplete-trigger',\n    '[attr.autocomplete]': 'autocompleteAttribute',\n    '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n    '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n    '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n    '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n    '[attr.aria-controls]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n    '[attr.aria-haspopup]': 'autocompleteDisabled ? null : \"listbox\"',\n    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n    // a little earlier. This avoids issues where IE delays the focusing of the input.\n    '(focusin)': '_handleFocus()',\n    '(blur)': '_onTouched()',\n    '(input)': '_handleInput($event)',\n    '(keydown)': '_handleKeydown($event)',\n    '(click)': '_handleClick()',\n  },\n  exportAs: 'matAutocompleteTrigger',\n  providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR],\n})\nexport class MatAutocompleteTrigger\n  implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy\n{\n  private _overlayRef: OverlayRef | null;\n  private _portal: TemplatePortal;\n  private _componentDestroyed = false;\n  private _scrollStrategy: () => ScrollStrategy;\n  private _keydownSubscription: Subscription | null;\n  private _outsideClickSubscription: Subscription | null;\n\n  /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n  private _previousValue: string | number | null;\n\n  /** Value of the input element when the panel was attached (even if there are no options). */\n  private _valueOnAttach: string | number | null;\n\n  /** Strategy that is used to position the panel. */\n  private _positionStrategy: FlexibleConnectedPositionStrategy;\n\n  /** Whether or not the label state is being overridden. */\n  private _manuallyFloatingLabel = false;\n\n  /** The subscription for closing actions (some are bound to document). */\n  private _closingActionsSubscription: Subscription;\n\n  /** Subscription to viewport size changes. */\n  private _viewportSubscription = Subscription.EMPTY;\n\n  /**\n   * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n   * closed autocomplete from being reopened if the user switches to another browser tab and then\n   * comes back.\n   */\n  private _canOpenOnNextFocus = true;\n\n  /** Value inside the input before we auto-selected an option. */\n  private _valueBeforeAutoSelection: string | undefined;\n\n  /**\n   * Current option that we have auto-selected as the user is navigating,\n   * but which hasn't been propagated to the model value yet.\n   */\n  private _pendingAutoselectedOption: MatOption | null;\n\n  /** Stream of keyboard events that can close the panel. */\n  private readonly _closeKeyEventStream = new Subject<void>();\n\n  /**\n   * Event handler for when the window is blurred. Needs to be an\n   * arrow function in order to preserve the context.\n   */\n  private _windowBlurHandler = () => {\n    // If the user blurred the window while the autocomplete is focused, it means that it'll be\n    // refocused when they come back. In this case we want to skip the first focus event, if the\n    // pane was closed, in order to avoid reopening it unintentionally.\n    this._canOpenOnNextFocus =\n      this._document.activeElement !== this._element.nativeElement || this.panelOpen;\n  };\n\n  /** `View -> model callback called when value changes` */\n  _onChange: (value: any) => void = () => {};\n\n  /** `View -> model callback called when autocomplete has been touched` */\n  _onTouched = () => {};\n\n  /** The autocomplete panel to be attached to this trigger. */\n  @Input('matAutocomplete') autocomplete: MatAutocomplete;\n\n  /**\n   * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n   * will render the panel underneath the trigger if there is enough space for it to fit in\n   * the viewport, otherwise the panel will be shown above it. If the position is set to\n   * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n   * whether it fits completely in the viewport.\n   */\n  @Input('matAutocompletePosition') position: 'auto' | 'above' | 'below' = 'auto';\n\n  /**\n   * Reference relative to which to position the autocomplete panel.\n   * Defaults to the autocomplete trigger element.\n   */\n  @Input('matAutocompleteConnectedTo') connectedTo: MatAutocompleteOrigin;\n\n  /**\n   * `autocomplete` attribute to be set on the input element.\n   * @docs-private\n   */\n  @Input('autocomplete') autocompleteAttribute: string = 'off';\n\n  /**\n   * Whether the autocomplete is disabled. When disabled, the element will\n   * act as a regular input and the user won't be able to open the panel.\n   */\n  @Input({alias: 'matAutocompleteDisabled', transform: booleanAttribute})\n  autocompleteDisabled: boolean;\n\n  constructor(\n    private _element: ElementRef<HTMLInputElement>,\n    private _overlay: Overlay,\n    private _viewContainerRef: ViewContainerRef,\n    private _zone: NgZone,\n    private _changeDetectorRef: ChangeDetectorRef,\n    @Inject(MAT_AUTOCOMPLETE_SCROLL_STRATEGY) scrollStrategy: any,\n    @Optional() private _dir: Directionality | null,\n    @Optional() @Inject(MAT_FORM_FIELD) @Host() private _formField: MatFormField | null,\n    @Optional() @Inject(DOCUMENT) private _document: any,\n    private _viewportRuler: ViewportRuler,\n    @Optional()\n    @Inject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS)\n    private _defaults?: MatAutocompleteDefaultOptions | null,\n  ) {\n    this._scrollStrategy = scrollStrategy;\n  }\n\n  /** Class to apply to the panel when it's above the input. */\n  private _aboveClass = 'mat-mdc-autocomplete-panel-above';\n\n  ngAfterViewInit() {\n    const window = this._getWindow();\n\n    if (typeof window !== 'undefined') {\n      this._zone.runOutsideAngular(() => window.addEventListener('blur', this._windowBlurHandler));\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['position'] && this._positionStrategy) {\n      this._setStrategyPositions(this._positionStrategy);\n\n      if (this.panelOpen) {\n        this._overlayRef!.updatePosition();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    const window = this._getWindow();\n\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('blur', this._windowBlurHandler);\n    }\n\n    this._viewportSubscription.unsubscribe();\n    this._componentDestroyed = true;\n    this._destroyPanel();\n    this._closeKeyEventStream.complete();\n    this._clearFromModal();\n  }\n\n  /** Whether or not the autocomplete panel is open. */\n  get panelOpen(): boolean {\n    return this._overlayAttached && this.autocomplete.showPanel;\n  }\n  private _overlayAttached: boolean = false;\n\n  /** Opens the autocomplete suggestion panel. */\n  openPanel(): void {\n    this._attachOverlay();\n    this._floatLabel();\n    // Add aria-owns attribute when the autocomplete becomes visible.\n    if (this._trackedModal) {\n      const panelId = this.autocomplete.id;\n      addAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n  }\n\n  /** Closes the autocomplete suggestion panel. */\n  closePanel(): void {\n    this._resetLabel();\n\n    if (!this._overlayAttached) {\n      return;\n    }\n\n    if (this.panelOpen) {\n      // Only emit if the panel was visible.\n      // The `NgZone.onStable` always emits outside of the Angular zone,\n      // so all the subscriptions from `_subscribeToClosingActions()` are also outside of the Angular zone.\n      // We should manually run in Angular zone to update UI after panel closing.\n      this._zone.run(() => {\n        this.autocomplete.closed.emit();\n      });\n    }\n\n    this.autocomplete._isOpen = this._overlayAttached = false;\n    this._pendingAutoselectedOption = null;\n\n    if (this._overlayRef && this._overlayRef.hasAttached()) {\n      this._overlayRef.detach();\n      this._closingActionsSubscription.unsubscribe();\n    }\n\n    this._updatePanelState();\n\n    // Note that in some cases this can end up being called after the component is destroyed.\n    // Add a check to ensure that we don't try to run change detection on a destroyed view.\n    if (!this._componentDestroyed) {\n      // We need to trigger change detection manually, because\n      // `fromEvent` doesn't seem to do it at the proper time.\n      // This ensures that the label is reset when the\n      // user clicks outside.\n      this._changeDetectorRef.detectChanges();\n    }\n\n    // Remove aria-owns attribute when the autocomplete is no longer visible.\n    if (this._trackedModal) {\n      const panelId = this.autocomplete.id;\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n  }\n\n  /**\n   * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n   * within the viewport.\n   */\n  updatePosition(): void {\n    if (this._overlayAttached) {\n      this._overlayRef!.updatePosition();\n    }\n  }\n\n  /**\n   * A stream of actions that should close the autocomplete panel, including\n   * when an option is selected, on blur, and when TAB is pressed.\n   */\n  get panelClosingActions(): Observable<MatOptionSelectionChange | null> {\n    return merge(\n      this.optionSelections,\n      this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)),\n      this._closeKeyEventStream,\n      this._getOutsideClickStream(),\n      this._overlayRef\n        ? this._overlayRef.detachments().pipe(filter(() => this._overlayAttached))\n        : observableOf(),\n    ).pipe(\n      // Normalize the output so we return a consistent type.\n      map(event => (event instanceof MatOptionSelectionChange ? event : null)),\n    );\n  }\n\n  /** Stream of changes to the selection state of the autocomplete options. */\n  readonly optionSelections: Observable<MatOptionSelectionChange> = defer(() => {\n    const options = this.autocomplete ? this.autocomplete.options : null;\n\n    if (options) {\n      return options.changes.pipe(\n        startWith(options),\n        switchMap(() => merge(...options.map(option => option.onSelectionChange))),\n      );\n    }\n\n    // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n    // Return a stream that we'll replace with the real one once everything is in place.\n    return this._zone.onStable.pipe(\n      take(1),\n      switchMap(() => this.optionSelections),\n    );\n  }) as Observable<MatOptionSelectionChange>;\n\n  /** The currently active option, coerced to MatOption type. */\n  get activeOption(): MatOption | null {\n    if (this.autocomplete && this.autocomplete._keyManager) {\n      return this.autocomplete._keyManager.activeItem;\n    }\n\n    return null;\n  }\n\n  /** Stream of clicks outside of the autocomplete panel. */\n  private _getOutsideClickStream(): Observable<any> {\n    return merge(\n      fromEvent(this._document, 'click') as Observable<MouseEvent>,\n      fromEvent(this._document, 'auxclick') as Observable<MouseEvent>,\n      fromEvent(this._document, 'touchend') as Observable<TouchEvent>,\n    ).pipe(\n      filter(event => {\n        // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n        // fall back to check the first element in the path of the click event.\n        const clickTarget = _getEventTarget<HTMLElement>(event)!;\n        const formField = this._formField ? this._formField._elementRef.nativeElement : null;\n        const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n\n        return (\n          this._overlayAttached &&\n          clickTarget !== this._element.nativeElement &&\n          // Normally focus moves inside `mousedown` so this condition will almost always be\n          // true. Its main purpose is to handle the case where the input is focused from an\n          // outside click which propagates up to the `body` listener within the same sequence\n          // and causes the panel to close immediately (see #3106).\n          this._document.activeElement !== this._element.nativeElement &&\n          (!formField || !formField.contains(clickTarget)) &&\n          (!customOrigin || !customOrigin.contains(clickTarget)) &&\n          !!this._overlayRef &&\n          !this._overlayRef.overlayElement.contains(clickTarget)\n        );\n      }),\n    );\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  writeValue(value: any): void {\n    Promise.resolve(null).then(() => this._assignOptionValue(value));\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnChange(fn: (value: any) => {}): void {\n    this._onChange = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnTouched(fn: () => {}) {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  setDisabledState(isDisabled: boolean) {\n    this._element.nativeElement.disabled = isDisabled;\n  }\n\n  _handleKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const hasModifier = hasModifierKey(event);\n\n    // Prevent the default action on all escape key presses. This is here primarily to bring IE\n    // in line with other browsers. By default, pressing escape on IE will cause it to revert\n    // the input value to the one that it had on focus, however it won't dispatch any events\n    // which means that the model value will be out of sync with the view.\n    if (keyCode === ESCAPE && !hasModifier) {\n      event.preventDefault();\n    }\n\n    if (this.activeOption && keyCode === ENTER && this.panelOpen && !hasModifier) {\n      this.activeOption._selectViaInteraction();\n      this._resetActiveItem();\n      event.preventDefault();\n    } else if (this.autocomplete) {\n      const prevActiveItem = this.autocomplete._keyManager.activeItem;\n      const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n      if (keyCode === TAB || (isArrowKey && !hasModifier && this.panelOpen)) {\n        this.autocomplete._keyManager.onKeydown(event);\n      } else if (isArrowKey && this._canOpen()) {\n        this.openPanel();\n      }\n\n      if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n        this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\n\n        if (this.autocomplete.autoSelectActiveOption && this.activeOption) {\n          if (!this._pendingAutoselectedOption) {\n            this._valueBeforeAutoSelection = this._element.nativeElement.value;\n          }\n\n          this._pendingAutoselectedOption = this.activeOption;\n          this._assignOptionValue(this.activeOption.value);\n        }\n      }\n    }\n  }\n\n  _handleInput(event: KeyboardEvent): void {\n    let target = event.target as HTMLInputElement;\n    let value: number | string | null = target.value;\n\n    // Based on `NumberValueAccessor` from forms.\n    if (target.type === 'number') {\n      value = value == '' ? null : parseFloat(value);\n    }\n\n    // If the input has a placeholder, IE will fire the `input` event on page load,\n    // focus and blur, in addition to when the user actually changed the value. To\n    // filter out all of the extra events, we save the value on focus and between\n    // `input` events, and we check whether it changed.\n    // See: https://connect.microsoft.com/IE/feedback/details/885747/\n    if (this._previousValue !== value) {\n      this._previousValue = value;\n      this._pendingAutoselectedOption = null;\n\n      // If selection is required we don't write to the CVA while the user is typing.\n      // At the end of the selection either the user will have picked something\n      // or we'll reset the value back to null.\n      if (!this.autocomplete || !this.autocomplete.requireSelection) {\n        this._onChange(value);\n      }\n\n      if (!value) {\n        this._clearPreviousSelectedOption(null, false);\n      }\n\n      if (this._canOpen() && this._document.activeElement === event.target) {\n        this.openPanel();\n      }\n    }\n  }\n\n  _handleFocus(): void {\n    if (!this._canOpenOnNextFocus) {\n      this._canOpenOnNextFocus = true;\n    } else if (this._canOpen()) {\n      this._previousValue = this._element.nativeElement.value;\n      this._attachOverlay();\n      this._floatLabel(true);\n    }\n  }\n\n  _handleClick(): void {\n    if (this._canOpen() && !this.panelOpen) {\n      this.openPanel();\n    }\n  }\n\n  /**\n   * In \"auto\" mode, the label will animate down as soon as focus is lost.\n   * This causes the value to jump when selecting an option with the mouse.\n   * This method manually floats the label until the panel can be closed.\n   * @param shouldAnimate Whether the label should be animated when it is floated.\n   */\n  private _floatLabel(shouldAnimate = false): void {\n    if (this._formField && this._formField.floatLabel === 'auto') {\n      if (shouldAnimate) {\n        this._formField._animateAndLockLabel();\n      } else {\n        this._formField.floatLabel = 'always';\n      }\n\n      this._manuallyFloatingLabel = true;\n    }\n  }\n\n  /** If the label has been manually elevated, return it to its normal state. */\n  private _resetLabel(): void {\n    if (this._manuallyFloatingLabel) {\n      if (this._formField) {\n        this._formField.floatLabel = 'auto';\n      }\n      this._manuallyFloatingLabel = false;\n    }\n  }\n\n  /**\n   * This method listens to a stream of panel closing actions and resets the\n   * stream every time the option list changes.\n   */\n  private _subscribeToClosingActions(): Subscription {\n    const firstStable = this._zone.onStable.pipe(take(1));\n    const optionChanges = this.autocomplete.options.changes.pipe(\n      tap(() => this._positionStrategy.reapplyLastPosition()),\n      // Defer emitting to the stream until the next tick, because changing\n      // bindings in here will cause \"changed after checked\" errors.\n      delay(0),\n    );\n\n    // When the zone is stable initially, and when the option list changes...\n    return (\n      merge(firstStable, optionChanges)\n        .pipe(\n          // create a new stream of panelClosingActions, replacing any previous streams\n          // that were created, and flatten it so our stream only emits closing events...\n          switchMap(() => {\n            // The `NgZone.onStable` always emits outside of the Angular zone, thus we have to re-enter\n            // the Angular zone. This will lead to change detection being called outside of the Angular\n            // zone and the `autocomplete.opened` will also emit outside of the Angular.\n            this._zone.run(() => {\n              const wasOpen = this.panelOpen;\n              this._resetActiveItem();\n              this._updatePanelState();\n              this._changeDetectorRef.detectChanges();\n\n              if (this.panelOpen) {\n                this._overlayRef!.updatePosition();\n              }\n\n              if (wasOpen !== this.panelOpen) {\n                // If the `panelOpen` state changed, we need to make sure to emit the `opened` or\n                // `closed` event, because we may not have emitted it. This can happen\n                // - if the users opens the panel and there are no options, but the\n                //   options come in slightly later or as a result of the value changing,\n                // - if the panel is closed after the user entered a string that did not match any\n                //   of the available options,\n                // - if a valid string is entered after an invalid one.\n                if (this.panelOpen) {\n                  this._emitOpened();\n                } else {\n                  this.autocomplete.closed.emit();\n                }\n              }\n            });\n\n            return this.panelClosingActions;\n          }),\n          // when the first closing event occurs...\n          take(1),\n        )\n        // set the value, close the panel, and complete.\n        .subscribe(event => this._setValueAndClose(event))\n    );\n  }\n\n  /**\n   * Emits the opened event once it's known that the panel will be shown and stores\n   * the state of the trigger right before the opening sequence was finished.\n   */\n  private _emitOpened() {\n    this.autocomplete.opened.emit();\n  }\n\n  /** Destroys the autocomplete suggestion panel. */\n  private _destroyPanel(): void {\n    if (this._overlayRef) {\n      this.closePanel();\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n  }\n\n  private _assignOptionValue(value: any): void {\n    const toDisplay =\n      this.autocomplete && this.autocomplete.displayWith\n        ? this.autocomplete.displayWith(value)\n        : value;\n\n    // Simply falling back to an empty string if the display value is falsy does not work properly.\n    // The display value can also be the number zero and shouldn't fall back to an empty string.\n    this._updateNativeInputValue(toDisplay != null ? toDisplay : '');\n  }\n\n  private _updateNativeInputValue(value: string): void {\n    // We want to clear the previous selection if our new value is falsy. e.g: reactive form field\n    // being reset.\n    if (!value) {\n      this._clearPreviousSelectedOption(null, false);\n    }\n\n    // If it's used within a `MatFormField`, we should set it through the property so it can go\n    // through change detection.\n    if (this._formField) {\n      this._formField._control.value = value;\n    } else {\n      this._element.nativeElement.value = value;\n    }\n\n    this._previousValue = value;\n  }\n\n  /**\n   * This method closes the panel, and if a value is specified, also sets the associated\n   * control to that value. It will also mark the control as dirty if this interaction\n   * stemmed from the user.\n   */\n  private _setValueAndClose(event: MatOptionSelectionChange | null): void {\n    const panel = this.autocomplete;\n    const toSelect = event ? event.source : this._pendingAutoselectedOption;\n\n    if (toSelect) {\n      this._clearPreviousSelectedOption(toSelect);\n      this._assignOptionValue(toSelect.value);\n      // TODO(crisbeto): this should wait until the animation is done, otherwise the value\n      // gets reset while the panel is still animating which looks glitchy. It'll likely break\n      // some tests to change it at this point.\n      this._onChange(toSelect.value);\n      panel._emitSelectEvent(toSelect);\n      this._element.nativeElement.focus();\n    } else if (\n      panel.requireSelection &&\n      this._element.nativeElement.value !== this._valueOnAttach\n    ) {\n      this._clearPreviousSelectedOption(null);\n      this._assignOptionValue(null);\n      // Wait for the animation to finish before clearing the form control value, otherwise\n      // the options might change while the animation is running which looks glitchy.\n      if (panel._animationDone) {\n        panel._animationDone.pipe(take(1)).subscribe(() => this._onChange(null));\n      } else {\n        this._onChange(null);\n      }\n    }\n\n    this.closePanel();\n  }\n\n  /**\n   * Clear any previous selected option and emit a selection change event for this option\n   */\n  private _clearPreviousSelectedOption(skip: MatOption | null, emitEvent?: boolean) {\n    // Null checks are necessary here, because the autocomplete\n    // or its options may not have been assigned yet.\n    this.autocomplete?.options?.forEach(option => {\n      if (option !== skip && option.selected) {\n        option.deselect(emitEvent);\n      }\n    });\n  }\n\n  private _attachOverlay(): void {\n    if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatAutocompleteMissingPanelError();\n    }\n\n    let overlayRef = this._overlayRef;\n\n    if (!overlayRef) {\n      this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, {\n        id: this._formField?.getLabelId(),\n      });\n      overlayRef = this._overlay.create(this._getOverlayConfig());\n      this._overlayRef = overlayRef;\n      this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\n        if (this.panelOpen && overlayRef) {\n          overlayRef.updateSize({width: this._getPanelWidth()});\n        }\n      });\n    } else {\n      // Update the trigger, panel width and direction, in case anything has changed.\n      this._positionStrategy.setOrigin(this._getConnectedElement());\n      overlayRef.updateSize({width: this._getPanelWidth()});\n    }\n\n    if (overlayRef && !overlayRef.hasAttached()) {\n      overlayRef.attach(this._portal);\n      this._valueOnAttach = this._element.nativeElement.value;\n      this._closingActionsSubscription = this._subscribeToClosingActions();\n    }\n\n    const wasOpen = this.panelOpen;\n\n    this.autocomplete._isOpen = this._overlayAttached = true;\n    this.autocomplete._setColor(this._formField?.color);\n    this._updatePanelState();\n    this._applyModalPanelOwnership();\n\n    // We need to do an extra `panelOpen` check in here, because the\n    // autocomplete won't be shown if there are no options.\n    if (this.panelOpen && wasOpen !== this.panelOpen) {\n      this._emitOpened();\n    }\n  }\n\n  /** Handles keyboard events coming from the overlay panel. */\n  private _handlePanelKeydown = (event: KeyboardEvent) => {\n    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n    if (\n      (event.keyCode === ESCAPE && !hasModifierKey(event)) ||\n      (event.keyCode === UP_ARROW && hasModifierKey(event, 'altKey'))\n    ) {\n      // If the user had typed something in before we autoselected an option, and they decided\n      // to cancel the selection, restore the input value to the one they had typed in.\n      if (this._pendingAutoselectedOption) {\n        this._updateNativeInputValue(this._valueBeforeAutoSelection ?? '');\n        this._pendingAutoselectedOption = null;\n      }\n      this._closeKeyEventStream.next();\n      this._resetActiveItem();\n      // We need to stop propagation, otherwise the event will eventually\n      // reach the input itself and cause the overlay to be reopened.\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  };\n\n  /** Updates the panel's visibility state and any trigger state tied to id. */\n  private _updatePanelState() {\n    this.autocomplete._setVisibility();\n\n    // Note that here we subscribe and unsubscribe based on the panel's visiblity state,\n    // because the act of subscribing will prevent events from reaching other overlays and\n    // we don't want to block the events if there are no options.\n    if (this.panelOpen) {\n      const overlayRef = this._overlayRef!;\n\n      if (!this._keydownSubscription) {\n        // Use the `keydownEvents` in order to take advantage of\n        // the overlay event targeting provided by the CDK overlay.\n        this._keydownSubscription = overlayRef.keydownEvents().subscribe(this._handlePanelKeydown);\n      }\n\n      if (!this._outsideClickSubscription) {\n        // Subscribe to the pointer events stream so that it doesn't get picked up by other overlays.\n        // TODO(crisbeto): we should switch `_getOutsideClickStream` eventually to use this stream,\n        // but the behvior isn't exactly the same and it ends up breaking some internal tests.\n        this._outsideClickSubscription = overlayRef.outsidePointerEvents().subscribe();\n      }\n    } else {\n      this._keydownSubscription?.unsubscribe();\n      this._outsideClickSubscription?.unsubscribe();\n      this._keydownSubscription = this._outsideClickSubscription = null;\n    }\n  }\n\n  private _getOverlayConfig(): OverlayConfig {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPosition(),\n      scrollStrategy: this._scrollStrategy(),\n      width: this._getPanelWidth(),\n      direction: this._dir ?? undefined,\n      panelClass: this._defaults?.overlayPanelClass,\n    });\n  }\n\n  private _getOverlayPosition(): PositionStrategy {\n    const strategy = this._overlay\n      .position()\n      .flexibleConnectedTo(this._getConnectedElement())\n      .withFlexibleDimensions(false)\n      .withPush(false);\n\n    this._setStrategyPositions(strategy);\n    this._positionStrategy = strategy;\n    return strategy;\n  }\n\n  /** Sets the positions on a position strategy based on the directive's input state. */\n  private _setStrategyPositions(positionStrategy: FlexibleConnectedPositionStrategy) {\n    // Note that we provide horizontal fallback positions, even though by default the dropdown\n    // width matches the input, because consumers can override the width. See #18854.\n    const belowPositions: ConnectedPosition[] = [\n      {originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top'},\n      {originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top'},\n    ];\n\n    // The overlay edge connected to the trigger should have squared corners, while\n    // the opposite end has rounded corners. We apply a CSS class to swap the\n    // border-radius based on the overlay position.\n    const panelClass = this._aboveClass;\n    const abovePositions: ConnectedPosition[] = [\n      {originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass},\n      {originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass},\n    ];\n\n    let positions: ConnectedPosition[];\n\n    if (this.position === 'above') {\n      positions = abovePositions;\n    } else if (this.position === 'below') {\n      positions = belowPositions;\n    } else {\n      positions = [...belowPositions, ...abovePositions];\n    }\n\n    positionStrategy.withPositions(positions);\n  }\n\n  private _getConnectedElement(): ElementRef<HTMLElement> {\n    if (this.connectedTo) {\n      return this.connectedTo.elementRef;\n    }\n\n    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n  }\n\n  private _getPanelWidth(): number | string {\n    return this.autocomplete.panelWidth || this._getHostWidth();\n  }\n\n  /** Returns the width of the input element, so the panel width can match it. */\n  private _getHostWidth(): number {\n    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n  }\n\n  /**\n   * Reset the active item to -1. This is so that pressing arrow keys will activate the correct\n   * option.\n   *\n   * If the consumer opted-in to automatically activatating the first option, activate the first\n   * *enabled* option.\n   */\n  private _resetActiveItem(): void {\n    const autocomplete = this.autocomplete;\n\n    if (autocomplete.autoActiveFirstOption) {\n      // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n      // because it activates the first option that passes the skip predicate, rather than the\n      // first *enabled* option.\n      let firstEnabledOptionIndex = -1;\n\n      for (let index = 0; index < autocomplete.options.length; index++) {\n        const option = autocomplete.options.get(index)!;\n        if (!option.disabled) {\n          firstEnabledOptionIndex = index;\n          break;\n        }\n      }\n      autocomplete._keyManager.setActiveItem(firstEnabledOptionIndex);\n    } else {\n      autocomplete._keyManager.setActiveItem(-1);\n    }\n  }\n\n  /** Determines whether the panel can be opened. */\n  private _canOpen(): boolean {\n    const element = this._element.nativeElement;\n    return !element.readOnly && !element.disabled && !this.autocompleteDisabled;\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    return this._document?.defaultView || window;\n  }\n\n  /** Scrolls to a particular option in the list. */\n  private _scrollToOption(index: number): void {\n    // Given that we are not actually focusing active options, we must manually adjust scroll\n    // to reveal options below the fold. First, we find the offset of the option from the top\n    // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n    // the panel height + the option height, so the active option will be just visible at the\n    // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n    // will become the offset. If that offset is visible within the panel already, the scrollTop is\n    // not adjusted.\n    const autocomplete = this.autocomplete;\n    const labelCount = _countGroupLabelsBeforeOption(\n      index,\n      autocomplete.options,\n      autocomplete.optionGroups,\n    );\n\n    if (index === 0 && labelCount === 1) {\n      // If we've got one group label before the option and we're at the top option,\n      // scroll the list to the top. This is better UX than scrolling the list to the\n      // top of the option, because it allows the user to read the top group's label.\n      autocomplete._setScrollTop(0);\n    } else if (autocomplete.panel) {\n      const option = autocomplete.options.toArray()[index];\n\n      if (option) {\n        const element = option._getHostElement();\n        const newScrollPosition = _getOptionScrollPosition(\n          element.offsetTop,\n          element.offsetHeight,\n          autocomplete._getScrollTop(),\n          autocomplete.panel.nativeElement.offsetHeight,\n        );\n\n        autocomplete._setScrollTop(newScrollPosition);\n      }\n    }\n  }\n\n  /**\n   * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n   * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n   * panel. Track the modal we have changed so we can undo the changes on destroy.\n   */\n  private _trackedModal: Element | null = null;\n\n  /**\n   * If the autocomplete trigger is inside of an `aria-modal` element, connect\n   * that modal to the options panel with `aria-owns`.\n   *\n   * For some browser + screen reader combinations, when navigation is inside\n   * of an `aria-modal` element, the screen reader treats everything outside\n   * of that modal as hidden or invisible.\n   *\n   * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n   * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n   * from reaching the panel.\n   *\n   * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n   * the options panel. This effectively communicates to assistive technology that the\n   * options panel is part of the same interaction as the modal.\n   *\n   * At time of this writing, this issue is present in VoiceOver.\n   * See https://github.com/angular/components/issues/20694\n   */\n  private _applyModalPanelOwnership() {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n    // the `LiveAnnouncer` and any other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const modal = this._element.nativeElement.closest(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    if (!modal) {\n      // Most commonly, the autocomplete trigger is not inside a modal.\n      return;\n    }\n\n    const panelId = this.autocomplete.id;\n\n    if (this._trackedModal) {\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n\n    addAriaReferencedId(modal, 'aria-owns', panelId);\n    this._trackedModal = modal;\n  }\n\n  /** Clears the references to the listbox overlay element from the modal it was added to. */\n  private _clearFromModal() {\n    if (this._trackedModal) {\n      const panelId = this.autocomplete.id;\n\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n      this._trackedModal = null;\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatOptionModule} from '@angular/material/core';\nimport {CommonModule} from '@angular/common';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {MatAutocomplete} from './autocomplete';\nimport {\n  MatAutocompleteTrigger,\n  MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER,\n} from './autocomplete-trigger';\nimport {MatAutocompleteOrigin} from './autocomplete-origin';\n\n@NgModule({\n  imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule],\n  exports: [\n    CdkScrollableModule,\n    MatAutocomplete,\n    MatOptionModule,\n    MatCommonModule,\n    MatAutocompleteTrigger,\n    MatAutocompleteOrigin,\n  ],\n  declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\n  providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n})\nexport class MatAutocompleteModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["_c0", "MatAutocomplete_ng_template_0_Template", "rf", "ctx", "_r4", "ɵɵgetCurrentView", "i0", "ɵɵelementStart", "ɵɵlistener", "MatAutocomplete_ng_template_0_Template_div_animation_panelAnimation_done_0_listener", "$event", "ɵɵrestoreView", "ctx_r3", "ɵɵnextContext", "ɵɵresetView", "_animationDone", "next", "ɵɵprojection", "ɵɵelementEnd", "formFieldId_r1", "id", "ctx_r0", "ɵɵproperty", "_classList", "isOpen", "ɵɵattribute", "ariaLabel", "_getPanelAriaLabelledby", "_c1", "panelAnimation", "trigger", "state", "style", "opacity", "transform", "transition", "group", "animate", "_uniqueAutocompleteIdCounter", "MatAutocompleteSelectedEvent", "constructor", "source", "option", "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS", "InjectionToken", "providedIn", "factory", "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY", "autoActiveFirstOption", "autoSelectActiveOption", "hideSingleSelectionIndicator", "requireSelection", "MatAutocomplete", "_isOpen", "showPanel", "_setColor", "value", "_color", "_setThemeClasses", "classList", "length", "coerceStringArray", "reduce", "className", "_setVisibilityClasses", "_elementRef", "nativeElement", "_hideSingleSelectionIndicator", "_syncParentProperties", "options", "_changeDetectorRef", "markForCheck", "_defaults", "platform", "_activeOptionChanges", "Subscription", "EMPTY", "_visibleClass", "_hiddenClass", "EventEmitter", "displayWith", "optionSelected", "opened", "closed", "optionActivated", "inertGroups", "SAFARI", "ngAfterContentInit", "_keyManager", "ActiveDescendantKeyManager", "withWrap", "skipPredicate", "_skipPredicate", "change", "subscribe", "index", "emit", "toArray", "_setVisibility", "ngOnDestroy", "destroy", "unsubscribe", "complete", "_setScrollTop", "scrollTop", "panel", "_getScrollTop", "_emitSelectEvent", "event", "labelId", "labelExpression", "ariaLabelledby", "ɵfac", "MatAutocomplete_Factory", "t", "ɵɵdirectiveInject", "ChangeDetectorRef", "ElementRef", "Platform", "ɵcmp", "ɵɵdefineComponent", "type", "selectors", "contentQueries", "MatAutocomplete_ContentQueries", "dirIndex", "ɵɵcontentQuery", "MatOption", "MAT_OPTGROUP", "_t", "ɵɵqueryRefresh", "ɵɵloadQuery", "optionGroups", "viewQuery", "MatAutocomplete_Query", "ɵɵviewQuery", "TemplateRef", "template", "first", "hostAttrs", "inputs", "booleanAttribute", "panelWidth", "disableRipple", "outputs", "exportAs", "features", "ɵɵProvidersFeature", "provide", "MAT_OPTION_PARENT_COMPONENT", "useExisting", "ɵɵInputTransformsFeature", "ngContentSelectors", "decls", "vars", "consts", "MatAutocomplete_Template", "ɵɵprojectionDef", "ɵɵtemplate", "dependencies", "NgClass", "styles", "encapsulation", "data", "animation", "changeDetection", "ɵsetClassMetadata", "Component", "ViewEncapsulation", "None", "ChangeDetectionStrategy", "OnPush", "host", "providers", "animations", "Inject", "ViewChild", "args", "static", "ContentChildren", "descendants", "Input", "Output", "MatAutocompleteOrigin", "elementRef", "ɵɵdefineDirective", "Directive", "selector", "MAT_AUTOCOMPLETE_VALUE_ACCESSOR", "NG_VALUE_ACCESSOR", "forwardRef", "MatAutocompleteTrigger", "multi", "getMatAutocompleteMissingPanelError", "Error", "MAT_AUTOCOMPLETE_SCROLL_STRATEGY", "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY", "overlay", "scrollStrategies", "reposition", "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER", "deps", "Overlay", "useFactory", "_element", "_overlay", "_viewContainerRef", "_zone", "scrollStrategy", "_dir", "_formField", "_document", "_viewportRuler", "_componentDestroyed", "_manuallyFloatingLabel", "_viewportSubscription", "_canOpenOnNextFocus", "_closeKeyEventStream", "Subject", "_windowBlurHandler", "activeElement", "panelOpen", "_onChange", "_onTouched", "position", "autocompleteAttribute", "_aboveClass", "_overlayAttached", "optionSelections", "defer", "autocomplete", "changes", "pipe", "startWith", "switchMap", "merge", "map", "onSelectionChange", "onStable", "take", "_handlePanelKeydown", "keyCode", "ESCAPE", "hasModifierKey", "UP_ARROW", "_pendingAutoselectedOption", "_updateNativeInputValue", "_valueBeforeAutoSelection", "_resetActiveItem", "stopPropagation", "preventDefault", "_trackedModal", "_scrollStrategy", "ngAfterViewInit", "window", "_getWindow", "runOutsideAngular", "addEventListener", "ngOnChanges", "_positionStrategy", "_setStrategyPositions", "_overlayRef", "updatePosition", "removeEventListener", "_destroyPanel", "_clearFromModal", "openPanel", "_attachOverlay", "_floatLabel", "panelId", "addAriaReferencedId", "closePanel", "_resetLabel", "run", "hasAttached", "detach", "_closingActionsSubscription", "_updatePanelState", "detectChanges", "removeAriaReferencedId", "panelClosingActions", "tabOut", "filter", "_getOutsideClickStream", "detachments", "of", "MatOptionSelectionChange", "activeOption", "activeItem", "fromEvent", "clickTarget", "_getEventTarget", "formField", "customOrigin", "connectedTo", "contains", "overlayElement", "writeValue", "Promise", "resolve", "then", "_assignOptionValue", "registerOnChange", "fn", "registerOnTouched", "setDisabledState", "isDisabled", "disabled", "_handleKeydown", "hasModifier", "ENTER", "_selectViaInteraction", "prevActiveItem", "isArrowKey", "DOWN_ARROW", "TAB", "onKeydown", "_canOpen", "_scrollToOption", "activeItemIndex", "_handleInput", "target", "parseFloat", "_previousValue", "_clearPreviousSelectedOption", "_handleFocus", "_handleClick", "shouldAnimate", "floatLabel", "_animateAndLockLabel", "_subscribeToClosingActions", "firstStable", "optionChanges", "tap", "reapplyLastPosition", "delay", "wasOpen", "_emitOpened", "_setValueAndClose", "dispose", "toDisplay", "_control", "toSelect", "focus", "_valueOnAttach", "skip", "emitEvent", "forEach", "selected", "deselect", "ngDevMode", "overlayRef", "_portal", "TemplatePortal", "getLabelId", "create", "_getOverlayConfig", "updateSize", "width", "_getPanelWidth", "setOrigin", "_getConnectedElement", "attach", "color", "_applyModalPanelOwnership", "_keydownSubscription", "keydownEvents", "_outsideClickSubscription", "outsidePointerEvents", "OverlayConfig", "positionStrategy", "_getOverlayPosition", "direction", "undefined", "panelClass", "overlayPanelClass", "strategy", "flexibleConnectedTo", "withFlexibleDimensions", "withPush", "belowPositions", "originX", "originY", "overlayX", "overlayY", "abovePositions", "positions", "withPositions", "getConnectedOverlayOrigin", "_getHostWidth", "getBoundingClientRect", "firstEnabledOptionIndex", "get", "setActiveItem", "element", "readOnly", "autocompleteDisabled", "defaultView", "labelCount", "_countGroupLabelsBeforeOption", "_getHostElement", "newScrollPosition", "_getOptionScrollPosition", "offsetTop", "offsetHeight", "modal", "closest", "MatAutocompleteTrigger_Factory", "ViewContainerRef", "NgZone", "Directionality", "MAT_FORM_FIELD", "DOCUMENT", "ViewportRuler", "ɵdir", "hostVars", "hostBindings", "MatAutocompleteTrigger_HostBindings", "MatAutocompleteTrigger_focusin_HostBindingHandler", "MatAutocompleteTrigger_blur_HostBindingHandler", "MatAutocompleteTrigger_input_HostBindingHandler", "MatAutocompleteTrigger_keydown_HostBindingHandler", "MatAutocompleteTrigger_click_HostBindingHandler", "toString", "ɵɵNgOnChangesFeature", "Optional", "Host", "alias", "MatAutocompleteModule", "ɵmod", "ɵɵdefineNgModule", "declarations", "imports", "OverlayModule", "MatOptionModule", "MatCommonModule", "CommonModule", "exports", "CdkScrollableModule", "ɵinj", "ɵɵdefineInjector", "NgModule"]
}
