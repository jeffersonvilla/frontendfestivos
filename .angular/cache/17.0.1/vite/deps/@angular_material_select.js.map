{
  "version": 3,
  "sources": ["../../../../../../../src/material/select/select-animations.ts", "../../../../../../../src/material/select/select-errors.ts", "../../../../../../../src/material/select/select.ts", "../../../../../../../src/material/select/select.html", "../../../../../../../src/material/select/module.ts", "../../../../../../../src/material/select/select_public_index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  animate,\n  animateChild,\n  AnimationTriggerMetadata,\n  query,\n  state,\n  style,\n  transition,\n  trigger,\n} from '@angular/animations';\n\n/**\n * The following are all the animations for the mat-select component, with each\n * const containing the metadata for one animation.\n *\n * The values below match the implementation of the AngularJS Material mat-select animation.\n * @docs-private\n */\nexport const matSelectAnimations: {\n  /**\n   * @deprecated No longer being used. To be removed.\n   * @breaking-change 12.0.0\n   */\n  readonly transformPanelWrap: AnimationTriggerMetadata;\n  readonly transformPanel: AnimationTriggerMetadata;\n} = {\n  /**\n   * This animation ensures the select's overlay panel animation (transformPanel) is called when\n   * closing the select.\n   * This is needed due to https://github.com/angular/angular/issues/23302\n   */\n  transformPanelWrap: trigger('transformPanelWrap', [\n    transition('* => void', query('@transformPanel', [animateChild()], {optional: true})),\n  ]),\n\n  /** This animation transforms the select's overlay panel on and off the page. */\n  transformPanel: trigger('transformPanel', [\n    state(\n      'void',\n      style({\n        opacity: 0,\n        transform: 'scale(1, 0.8)',\n      }),\n    ),\n    transition(\n      'void => showing',\n      animate(\n        '120ms cubic-bezier(0, 0, 0.2, 1)',\n        style({\n          opacity: 1,\n          transform: 'scale(1, 1)',\n        }),\n      ),\n    ),\n    transition('* => void', animate('100ms linear', style({opacity: 0}))),\n  ]),\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Note that these have been copied over verbatim from\n// `material/select` so that we don't have to expose them publicly.\n\n/**\n * Returns an exception to be thrown when attempting to change a select's `multiple` option\n * after initialization.\n * @docs-private\n */\nexport function getMatSelectDynamicMultipleError(): Error {\n  return Error('Cannot change `multiple` mode of select after initialization.');\n}\n\n/**\n * Returns an exception to be thrown when attempting to assign a non-array value to a select\n * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for\n * resetting the value.\n * @docs-private\n */\nexport function getMatSelectNonArrayValueError(): Error {\n  return Error('Value must be an array in multiple-selection mode.');\n}\n\n/**\n * Returns an exception to be thrown when assigning a non-function value to the comparator\n * used to determine if a value corresponds to an option. Note that whether the function\n * actually takes two values and returns a boolean is not checked.\n */\nexport function getMatSelectNonFunctionValueError(): Error {\n  return Error('`compareWith` must be a function.');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ActiveDescendantKeyManager,\n  LiveAnnouncer,\n  addAriaReferencedId,\n  removeAriaReferencedId,\n} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  BooleanInput,\n  coerceBooleanProperty,\n  coerceNumberProperty,\n  NumberInput,\n} from '@angular/cdk/coercion';\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {\n  A,\n  DOWN_ARROW,\n  ENTER,\n  hasModifierKey,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  SPACE,\n  UP_ARROW,\n} from '@angular/cdk/keycodes';\nimport {\n  CdkConnectedOverlay,\n  CdkOverlayOrigin,\n  ConnectedPosition,\n  Overlay,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {\n  AfterContentInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  Self,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  AbstractControl,\n  ControlValueAccessor,\n  FormGroupDirective,\n  NgControl,\n  NgForm,\n  Validators,\n} from '@angular/forms';\nimport {\n  CanDisable,\n  CanDisableRipple,\n  CanUpdateErrorState,\n  ErrorStateMatcher,\n  HasTabIndex,\n  MatOptgroup,\n  MatOption,\n  MatOptionSelectionChange,\n  MAT_OPTGROUP,\n  MAT_OPTION_PARENT_COMPONENT,\n  mixinDisabled,\n  mixinDisableRipple,\n  mixinErrorState,\n  mixinTabIndex,\n  _countGroupLabelsBeforeOption,\n  _getOptionScrollPosition,\n} from '@angular/material/core';\nimport {MatFormField, MatFormFieldControl, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {defer, merge, Observable, Subject} from 'rxjs';\nimport {\n  distinctUntilChanged,\n  filter,\n  map,\n  startWith,\n  switchMap,\n  take,\n  takeUntil,\n} from 'rxjs/operators';\nimport {matSelectAnimations} from './select-animations';\nimport {\n  getMatSelectDynamicMultipleError,\n  getMatSelectNonArrayValueError,\n  getMatSelectNonFunctionValueError,\n} from './select-errors';\n\nlet nextUniqueId = 0;\n\n/** Injection token that determines the scroll handling while a select is open. */\nexport const MAT_SELECT_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-select-scroll-strategy',\n);\n\n/** @docs-private */\nexport function MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(\n  overlay: Overlay,\n): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.reposition();\n}\n\n/** Object that can be used to configure the default options for the select module. */\nexport interface MatSelectConfig {\n  /** Whether option centering should be disabled. */\n  disableOptionCentering?: boolean;\n\n  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n  typeaheadDebounceInterval?: number;\n\n  /** Class or list of classes to be applied to the menu's overlay panel. */\n  overlayPanelClass?: string | string[];\n\n  /** Wheter icon indicators should be hidden for single-selection. */\n  hideSingleSelectionIndicator?: boolean;\n\n  /**\n   * Width of the panel. If set to `auto`, the panel will match the trigger width.\n   * If set to null or an empty string, the panel will grow to match the longest option's text.\n   */\n  panelWidth?: string | number | null;\n}\n\n/** Injection token that can be used to provide the default options the select module. */\nexport const MAT_SELECT_CONFIG = new InjectionToken<MatSelectConfig>('MAT_SELECT_CONFIG');\n\n/** @docs-private */\nexport const MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_SELECT_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\n/**\n * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as\n * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_SELECT_TRIGGER = new InjectionToken<MatSelectTrigger>('MatSelectTrigger');\n\n/** Change event object that is emitted when the select value has changed. */\nexport class MatSelectChange {\n  constructor(\n    /** Reference to the select that emitted the change event. */\n    public source: MatSelect,\n    /** Current value of the select that emitted the event. */\n    public value: any,\n  ) {}\n}\n\n// Boilerplate for applying mixins to MatSelect.\n/** @docs-private */\nconst _MatSelectMixinBase = mixinDisableRipple(\n  mixinTabIndex(\n    mixinDisabled(\n      mixinErrorState(\n        class {\n          /**\n           * Emits whenever the component state changes and should cause the parent\n           * form-field to update. Implemented as part of `MatFormFieldControl`.\n           * @docs-private\n           */\n          readonly stateChanges = new Subject<void>();\n\n          constructor(\n            public _elementRef: ElementRef,\n            public _defaultErrorStateMatcher: ErrorStateMatcher,\n            public _parentForm: NgForm,\n            public _parentFormGroup: FormGroupDirective,\n            /**\n             * Form control bound to the component.\n             * Implemented as part of `MatFormFieldControl`.\n             * @docs-private\n             */\n            public ngControl: NgControl,\n          ) {}\n        },\n      ),\n    ),\n  ),\n);\n\n@Component({\n  selector: 'mat-select',\n  exportAs: 'matSelect',\n  templateUrl: 'select.html',\n  styleUrls: ['select.css'],\n  inputs: ['disabled', 'disableRipple', 'tabIndex'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    'role': 'combobox',\n    'aria-autocomplete': 'none',\n    'aria-haspopup': 'listbox',\n    'class': 'mat-mdc-select',\n    '[attr.id]': 'id',\n    '[attr.tabindex]': 'tabIndex',\n    '[attr.aria-controls]': 'panelOpen ? id + \"-panel\" : null',\n    '[attr.aria-expanded]': 'panelOpen',\n    '[attr.aria-label]': 'ariaLabel || null',\n    '[attr.aria-required]': 'required.toString()',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.aria-invalid]': 'errorState',\n    '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',\n    'ngSkipHydration': '',\n    '[class.mat-mdc-select-disabled]': 'disabled',\n    '[class.mat-mdc-select-invalid]': 'errorState',\n    '[class.mat-mdc-select-required]': 'required',\n    '[class.mat-mdc-select-empty]': 'empty',\n    '[class.mat-mdc-select-multiple]': 'multiple',\n    '(keydown)': '_handleKeydown($event)',\n    '(focus)': '_onFocus()',\n    '(blur)': '_onBlur()',\n  },\n  animations: [matSelectAnimations.transformPanel],\n  providers: [\n    {provide: MatFormFieldControl, useExisting: MatSelect},\n    {provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect},\n  ],\n})\nexport class MatSelect\n  extends _MatSelectMixinBase\n  implements\n    AfterContentInit,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    DoCheck,\n    ControlValueAccessor,\n    CanDisable,\n    HasTabIndex,\n    MatFormFieldControl<any>,\n    CanUpdateErrorState,\n    CanDisableRipple\n{\n  /** All of the defined select options. */\n  @ContentChildren(MatOption, {descendants: true}) options: QueryList<MatOption>;\n\n  // TODO(crisbeto): this is only necessary for the non-MDC select, but it's technically a\n  // public API so we have to keep it. It should be deprecated and removed eventually.\n  /** All of the defined groups of options. */\n  @ContentChildren(MAT_OPTGROUP, {descendants: true}) optionGroups: QueryList<MatOptgroup>;\n\n  /** User-supplied override of the trigger element. */\n  @ContentChild(MAT_SELECT_TRIGGER) customTrigger: MatSelectTrigger;\n\n  /**\n   * This position config ensures that the top \"start\" corner of the overlay\n   * is aligned with with the top \"start\" of the origin by default (overlapping\n   * the trigger completely). If the panel cannot fit below the trigger, it\n   * will fall back to a position above the trigger.\n   */\n  _positions: ConnectedPosition[] = [\n    {\n      originX: 'start',\n      originY: 'bottom',\n      overlayX: 'start',\n      overlayY: 'top',\n    },\n    {\n      originX: 'end',\n      originY: 'bottom',\n      overlayX: 'end',\n      overlayY: 'top',\n    },\n    {\n      originX: 'start',\n      originY: 'top',\n      overlayX: 'start',\n      overlayY: 'bottom',\n      panelClass: 'mat-mdc-select-panel-above',\n    },\n    {\n      originX: 'end',\n      originY: 'top',\n      overlayX: 'end',\n      overlayY: 'bottom',\n      panelClass: 'mat-mdc-select-panel-above',\n    },\n  ];\n\n  /** Scrolls a particular option into the view. */\n  _scrollOptionIntoView(index: number): void {\n    const option = this.options.toArray()[index];\n\n    if (option) {\n      const panel: HTMLElement = this.panel.nativeElement;\n      const labelCount = _countGroupLabelsBeforeOption(index, this.options, this.optionGroups);\n      const element = option._getHostElement();\n\n      if (index === 0 && labelCount === 1) {\n        // If we've got one group label before the option and we're at the top option,\n        // scroll the list to the top. This is better UX than scrolling the list to the\n        // top of the option, because it allows the user to read the top group's label.\n        panel.scrollTop = 0;\n      } else {\n        panel.scrollTop = _getOptionScrollPosition(\n          element.offsetTop,\n          element.offsetHeight,\n          panel.scrollTop,\n          panel.offsetHeight,\n        );\n      }\n    }\n  }\n\n  /** Called when the panel has been opened and the overlay has settled on its final position. */\n  private _positioningSettled() {\n    this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n  }\n\n  /** Creates a change event object that should be emitted by the select. */\n  private _getChangeEvent(value: any) {\n    return new MatSelectChange(this, value);\n  }\n\n  /** Factory function used to create a scroll strategy for this select. */\n  private _scrollStrategyFactory: () => ScrollStrategy;\n\n  /** Whether or not the overlay panel is open. */\n  private _panelOpen = false;\n\n  /** Comparison function to specify which option is displayed. Defaults to object equality. */\n  private _compareWith = (o1: any, o2: any) => o1 === o2;\n\n  /** Unique id for this input. */\n  private _uid = `mat-select-${nextUniqueId++}`;\n\n  /** Current `aria-labelledby` value for the select trigger. */\n  private _triggerAriaLabelledBy: string | null = null;\n\n  /**\n   * Keeps track of the previous form control assigned to the select.\n   * Used to detect if it has changed.\n   */\n  private _previousControl: AbstractControl | null | undefined;\n\n  /** Emits whenever the component is destroyed. */\n  protected readonly _destroy = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /** Deals with the selection logic. */\n  _selectionModel: SelectionModel<MatOption>;\n\n  /** Manages keyboard events for options in the panel. */\n  _keyManager: ActiveDescendantKeyManager<MatOption>;\n\n  /** Ideal origin for the overlay panel. */\n  _preferredOverlayOrigin: CdkOverlayOrigin | ElementRef | undefined;\n\n  /** Width of the overlay panel. */\n  _overlayWidth: string | number;\n\n  /** `View -> model callback called when value changes` */\n  _onChange: (value: any) => void = () => {};\n\n  /** `View -> model callback called when select has been touched` */\n  _onTouched = () => {};\n\n  /** ID for the DOM node containing the select's value. */\n  _valueId = `mat-select-value-${nextUniqueId++}`;\n\n  /** Emits when the panel element is finished transforming in. */\n  readonly _panelDoneAnimatingStream = new Subject<string>();\n\n  /** Strategy that will be used to handle scrolling while the select panel is open. */\n  _scrollStrategy: ScrollStrategy;\n\n  _overlayPanelClass: string | string[] = this._defaultOptions?.overlayPanelClass || '';\n\n  /** Whether the select is focused. */\n  get focused(): boolean {\n    return this._focused || this._panelOpen;\n  }\n  private _focused = false;\n\n  /** A name for this control that can be used by `mat-form-field`. */\n  controlType = 'mat-select';\n\n  /** Trigger that opens the select. */\n  @ViewChild('trigger') trigger: ElementRef;\n\n  /** Panel containing the select options. */\n  @ViewChild('panel') panel: ElementRef;\n\n  /** Overlay pane containing the options. */\n  @ViewChild(CdkConnectedOverlay)\n  protected _overlayDir: CdkConnectedOverlay;\n\n  /** Classes to be passed to the select panel. Supports the same syntax as `ngClass`. */\n  @Input() panelClass: string | string[] | Set<string> | {[key: string]: any};\n\n  /** Whether checkmark indicator for single-selection options is hidden. */\n  @Input()\n  get hideSingleSelectionIndicator(): boolean {\n    return this._hideSingleSelectionIndicator;\n  }\n  set hideSingleSelectionIndicator(value: BooleanInput) {\n    this._hideSingleSelectionIndicator = coerceBooleanProperty(value);\n    this._syncParentProperties();\n  }\n  private _hideSingleSelectionIndicator: boolean =\n    this._defaultOptions?.hideSingleSelectionIndicator ?? false;\n\n  /** Placeholder to be shown if no value has been selected. */\n  @Input()\n  get placeholder(): string {\n    return this._placeholder;\n  }\n  set placeholder(value: string) {\n    this._placeholder = value;\n    this.stateChanges.next();\n  }\n  private _placeholder: string;\n\n  /** Whether the component is required. */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this.stateChanges.next();\n  }\n  private _required: boolean | undefined;\n\n  /** Whether the user should be allowed to select multiple options. */\n  @Input()\n  get multiple(): boolean {\n    return this._multiple;\n  }\n  set multiple(value: BooleanInput) {\n    if (this._selectionModel && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatSelectDynamicMultipleError();\n    }\n\n    this._multiple = coerceBooleanProperty(value);\n  }\n  private _multiple: boolean = false;\n\n  /** Whether to center the active option over the trigger. */\n  @Input()\n  get disableOptionCentering(): boolean {\n    return this._disableOptionCentering;\n  }\n  set disableOptionCentering(value: BooleanInput) {\n    this._disableOptionCentering = coerceBooleanProperty(value);\n  }\n  private _disableOptionCentering = this._defaultOptions?.disableOptionCentering ?? false;\n\n  /**\n   * Function to compare the option values with the selected values. The first argument\n   * is a value from an option. The second is a value from the selection. A boolean\n   * should be returned.\n   */\n  @Input()\n  get compareWith() {\n    return this._compareWith;\n  }\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatSelectNonFunctionValueError();\n    }\n    this._compareWith = fn;\n    if (this._selectionModel) {\n      // A different comparator means the selection could change.\n      this._initializeSelection();\n    }\n  }\n\n  /** Value of the select control. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    const hasAssigned = this._assignValue(newValue);\n\n    if (hasAssigned) {\n      this._onChange(newValue);\n    }\n  }\n  private _value: any;\n\n  /** Aria label of the select. */\n  @Input('aria-label') ariaLabel: string = '';\n\n  /** Input that can be used to specify the `aria-labelledby` attribute. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** Object used to control when error messages are shown. */\n  @Input() override errorStateMatcher: ErrorStateMatcher;\n\n  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n  @Input()\n  get typeaheadDebounceInterval(): number {\n    return this._typeaheadDebounceInterval;\n  }\n  set typeaheadDebounceInterval(value: NumberInput) {\n    this._typeaheadDebounceInterval = coerceNumberProperty(value);\n  }\n  private _typeaheadDebounceInterval: number;\n\n  /**\n   * Function used to sort the values in a select in multiple mode.\n   * Follows the same logic as `Array.prototype.sort`.\n   */\n  @Input() sortComparator: (a: MatOption, b: MatOption, options: MatOption[]) => number;\n\n  /** Unique id of the element. */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n    this.stateChanges.next();\n  }\n  private _id: string;\n\n  /**\n   * Width of the panel. If set to `auto`, the panel will match the trigger width.\n   * If set to null or an empty string, the panel will grow to match the longest option's text.\n   */\n  @Input() panelWidth: string | number | null =\n    this._defaultOptions && typeof this._defaultOptions.panelWidth !== 'undefined'\n      ? this._defaultOptions.panelWidth\n      : 'auto';\n\n  /** Combined stream of all of the child options' change events. */\n  readonly optionSelectionChanges: Observable<MatOptionSelectionChange> = defer(() => {\n    const options = this.options;\n\n    if (options) {\n      return options.changes.pipe(\n        startWith(options),\n        switchMap(() => merge(...options.map(option => option.onSelectionChange))),\n      );\n    }\n\n    return this._ngZone.onStable.pipe(\n      take(1),\n      switchMap(() => this.optionSelectionChanges),\n    );\n  }) as Observable<MatOptionSelectionChange>;\n\n  /** Event emitted when the select panel has been toggled. */\n  @Output() readonly openedChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /** Event emitted when the select has been opened. */\n  @Output('opened') readonly _openedStream: Observable<void> = this.openedChange.pipe(\n    filter(o => o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the select has been closed. */\n  @Output('closed') readonly _closedStream: Observable<void> = this.openedChange.pipe(\n    filter(o => !o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the selected value has been changed by the user. */\n  @Output() readonly selectionChange = new EventEmitter<MatSelectChange>();\n\n  /**\n   * Event that emits whenever the raw value of the select changes. This is here primarily\n   * to facilitate the two-way binding for the `value` input.\n   * @docs-private\n   */\n  @Output() readonly valueChange: EventEmitter<any> = new EventEmitter<any>();\n\n  constructor(\n    protected _viewportRuler: ViewportRuler,\n    protected _changeDetectorRef: ChangeDetectorRef,\n    protected _ngZone: NgZone,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    elementRef: ElementRef,\n    @Optional() private _dir: Directionality,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    @Optional() @Inject(MAT_FORM_FIELD) protected _parentFormField: MatFormField,\n    @Self() @Optional() ngControl: NgControl,\n    @Attribute('tabindex') tabIndex: string,\n    @Inject(MAT_SELECT_SCROLL_STRATEGY) scrollStrategyFactory: any,\n    private _liveAnnouncer: LiveAnnouncer,\n    @Optional() @Inject(MAT_SELECT_CONFIG) protected _defaultOptions?: MatSelectConfig,\n  ) {\n    super(elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    if (this.ngControl) {\n      // Note: we provide the value accessor through here, instead of\n      // the `providers` to avoid running into a circular import.\n      this.ngControl.valueAccessor = this;\n    }\n\n    // Note that we only want to set this when the defaults pass it in, otherwise it should\n    // stay as `undefined` so that it falls back to the default in the key manager.\n    if (_defaultOptions?.typeaheadDebounceInterval != null) {\n      this._typeaheadDebounceInterval = _defaultOptions.typeaheadDebounceInterval;\n    }\n\n    this._scrollStrategyFactory = scrollStrategyFactory;\n    this._scrollStrategy = this._scrollStrategyFactory();\n    this.tabIndex = parseInt(tabIndex) || 0;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n  }\n\n  ngOnInit() {\n    this._selectionModel = new SelectionModel<MatOption>(this.multiple);\n    this.stateChanges.next();\n\n    // We need `distinctUntilChanged` here, because some browsers will\n    // fire the animation end event twice for the same animation. See:\n    // https://github.com/angular/angular/issues/24084\n    this._panelDoneAnimatingStream\n      .pipe(distinctUntilChanged(), takeUntil(this._destroy))\n      .subscribe(() => this._panelDoneAnimating(this.panelOpen));\n\n    this._viewportRuler\n      .change()\n      .pipe(takeUntil(this._destroy))\n      .subscribe(() => {\n        if (this.panelOpen) {\n          this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);\n          this._changeDetectorRef.detectChanges();\n        }\n      });\n  }\n\n  ngAfterContentInit() {\n    this._initKeyManager();\n\n    this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe(event => {\n      event.added.forEach(option => option.select());\n      event.removed.forEach(option => option.deselect());\n    });\n\n    this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {\n      this._resetOptions();\n      this._initializeSelection();\n    });\n  }\n\n  ngDoCheck() {\n    const newAriaLabelledby = this._getTriggerAriaLabelledby();\n    const ngControl = this.ngControl;\n\n    // We have to manage setting the `aria-labelledby` ourselves, because part of its value\n    // is computed as a result of a content query which can cause this binding to trigger a\n    // \"changed after checked\" error.\n    if (newAriaLabelledby !== this._triggerAriaLabelledBy) {\n      const element: HTMLElement = this._elementRef.nativeElement;\n      this._triggerAriaLabelledBy = newAriaLabelledby;\n      if (newAriaLabelledby) {\n        element.setAttribute('aria-labelledby', newAriaLabelledby);\n      } else {\n        element.removeAttribute('aria-labelledby');\n      }\n    }\n\n    if (ngControl) {\n      // The disabled state might go out of sync if the form group is swapped out. See #17860.\n      if (this._previousControl !== ngControl.control) {\n        if (\n          this._previousControl !== undefined &&\n          ngControl.disabled !== null &&\n          ngControl.disabled !== this.disabled\n        ) {\n          this.disabled = ngControl.disabled;\n        }\n\n        this._previousControl = ngControl.control;\n      }\n\n      this.updateErrorState();\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let\n    // the parent form field know to run change detection when the disabled state changes.\n    if (changes['disabled'] || changes['userAriaDescribedBy']) {\n      this.stateChanges.next();\n    }\n\n    if (changes['typeaheadDebounceInterval'] && this._keyManager) {\n      this._keyManager.withTypeAhead(this._typeaheadDebounceInterval);\n    }\n  }\n\n  ngOnDestroy() {\n    this._keyManager?.destroy();\n    this._destroy.next();\n    this._destroy.complete();\n    this.stateChanges.complete();\n    this._clearFromModal();\n  }\n\n  /** Toggles the overlay panel open or closed. */\n  toggle(): void {\n    this.panelOpen ? this.close() : this.open();\n  }\n\n  /** Opens the overlay panel. */\n  open(): void {\n    // It's important that we read this as late as possible, because doing so earlier will\n    // return a different element since it's based on queries in the form field which may\n    // not have run yet. Also this needs to be assigned before we measure the overlay width.\n    if (this._parentFormField) {\n      this._preferredOverlayOrigin = this._parentFormField.getConnectedOverlayOrigin();\n    }\n\n    this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);\n\n    if (this._canOpen()) {\n      this._applyModalPanelOwnership();\n\n      this._panelOpen = true;\n      this._keyManager.withHorizontalOrientation(null);\n      this._highlightCorrectOption();\n      this._changeDetectorRef.markForCheck();\n    }\n    // Required for the MDC form field to pick up when the overlay has been opened.\n    this.stateChanges.next();\n  }\n\n  /**\n   * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n   * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n   * panel. Track the modal we have changed so we can undo the changes on destroy.\n   */\n  private _trackedModal: Element | null = null;\n\n  /**\n   * If the autocomplete trigger is inside of an `aria-modal` element, connect\n   * that modal to the options panel with `aria-owns`.\n   *\n   * For some browser + screen reader combinations, when navigation is inside\n   * of an `aria-modal` element, the screen reader treats everything outside\n   * of that modal as hidden or invisible.\n   *\n   * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n   * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n   * from reaching the panel.\n   *\n   * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n   * the options panel. This effectively communicates to assistive technology that the\n   * options panel is part of the same interaction as the modal.\n   *\n   * At time of this writing, this issue is present in VoiceOver.\n   * See https://github.com/angular/components/issues/20694\n   */\n  private _applyModalPanelOwnership() {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n    // the `LiveAnnouncer` and any other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const modal = this._elementRef.nativeElement.closest(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    if (!modal) {\n      // Most commonly, the autocomplete trigger is not inside a modal.\n      return;\n    }\n\n    const panelId = `${this.id}-panel`;\n\n    if (this._trackedModal) {\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n\n    addAriaReferencedId(modal, 'aria-owns', panelId);\n    this._trackedModal = modal;\n  }\n\n  /** Clears the reference to the listbox overlay element from the modal it was added to. */\n  private _clearFromModal() {\n    if (!this._trackedModal) {\n      // Most commonly, the autocomplete trigger is not used inside a modal.\n      return;\n    }\n\n    const panelId = `${this.id}-panel`;\n\n    removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    this._trackedModal = null;\n  }\n\n  /** Closes the overlay panel and focuses the host element. */\n  close(): void {\n    if (this._panelOpen) {\n      this._panelOpen = false;\n      this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n      this._changeDetectorRef.markForCheck();\n      this._onTouched();\n    }\n\n    // Required for the MDC form field to pick up when the overlay has been closed.\n    this.stateChanges.next();\n  }\n\n  /**\n   * Sets the select's value. Part of the ControlValueAccessor interface\n   * required to integrate with Angular's core forms API.\n   *\n   * @param value New value to be written to the model.\n   */\n  writeValue(value: any): void {\n    this._assignValue(value);\n  }\n\n  /**\n   * Saves a callback function to be invoked when the select's value\n   * changes from user input. Part of the ControlValueAccessor interface\n   * required to integrate with Angular's core forms API.\n   *\n   * @param fn Callback to be triggered when the value changes.\n   */\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Saves a callback function to be invoked when the select is blurred\n   * by the user. Part of the ControlValueAccessor interface required\n   * to integrate with Angular's core forms API.\n   *\n   * @param fn Callback to be triggered when the component has been touched.\n   */\n  registerOnTouched(fn: () => {}): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Disables the select. Part of the ControlValueAccessor interface required\n   * to integrate with Angular's core forms API.\n   *\n   * @param isDisabled Sets whether the component is disabled.\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this._changeDetectorRef.markForCheck();\n    this.stateChanges.next();\n  }\n\n  /** Whether or not the overlay panel is open. */\n  get panelOpen(): boolean {\n    return this._panelOpen;\n  }\n\n  /** The currently selected option. */\n  get selected(): MatOption | MatOption[] {\n    return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0];\n  }\n\n  /** The value displayed in the trigger. */\n  get triggerValue(): string {\n    if (this.empty) {\n      return '';\n    }\n\n    if (this._multiple) {\n      const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);\n\n      if (this._isRtl()) {\n        selectedOptions.reverse();\n      }\n\n      // TODO(crisbeto): delimiter should be configurable for proper localization.\n      return selectedOptions.join(', ');\n    }\n\n    return this._selectionModel.selected[0].viewValue;\n  }\n\n  /** Whether the element is in RTL mode. */\n  _isRtl(): boolean {\n    return this._dir ? this._dir.value === 'rtl' : false;\n  }\n\n  /** Handles all keydown events on the select. */\n  _handleKeydown(event: KeyboardEvent): void {\n    if (!this.disabled) {\n      this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);\n    }\n  }\n\n  /** Handles keyboard events while the select is closed. */\n  private _handleClosedKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const isArrowKey =\n      keyCode === DOWN_ARROW ||\n      keyCode === UP_ARROW ||\n      keyCode === LEFT_ARROW ||\n      keyCode === RIGHT_ARROW;\n    const isOpenKey = keyCode === ENTER || keyCode === SPACE;\n    const manager = this._keyManager;\n\n    // Open the select on ALT + arrow key to match the native <select>\n    if (\n      (!manager.isTyping() && isOpenKey && !hasModifierKey(event)) ||\n      ((this.multiple || event.altKey) && isArrowKey)\n    ) {\n      event.preventDefault(); // prevents the page from scrolling down when pressing space\n      this.open();\n    } else if (!this.multiple) {\n      const previouslySelectedOption = this.selected;\n      manager.onKeydown(event);\n      const selectedOption = this.selected;\n\n      // Since the value has changed, we need to announce it ourselves.\n      if (selectedOption && previouslySelectedOption !== selectedOption) {\n        // We set a duration on the live announcement, because we want the live element to be\n        // cleared after a while so that users can't navigate to it using the arrow keys.\n        this._liveAnnouncer.announce((selectedOption as MatOption).viewValue, 10000);\n      }\n    }\n  }\n\n  /** Handles keyboard events when the selected is open. */\n  private _handleOpenKeydown(event: KeyboardEvent): void {\n    const manager = this._keyManager;\n    const keyCode = event.keyCode;\n    const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n    const isTyping = manager.isTyping();\n\n    if (isArrowKey && event.altKey) {\n      // Close the select on ALT + arrow key to match the native <select>\n      event.preventDefault();\n      this.close();\n      // Don't do anything in this case if the user is typing,\n      // because the typing sequence can include the space key.\n    } else if (\n      !isTyping &&\n      (keyCode === ENTER || keyCode === SPACE) &&\n      manager.activeItem &&\n      !hasModifierKey(event)\n    ) {\n      event.preventDefault();\n      manager.activeItem._selectViaInteraction();\n    } else if (!isTyping && this._multiple && keyCode === A && event.ctrlKey) {\n      event.preventDefault();\n      const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);\n\n      this.options.forEach(option => {\n        if (!option.disabled) {\n          hasDeselectedOptions ? option.select() : option.deselect();\n        }\n      });\n    } else {\n      const previouslyFocusedIndex = manager.activeItemIndex;\n\n      manager.onKeydown(event);\n\n      if (\n        this._multiple &&\n        isArrowKey &&\n        event.shiftKey &&\n        manager.activeItem &&\n        manager.activeItemIndex !== previouslyFocusedIndex\n      ) {\n        manager.activeItem._selectViaInteraction();\n      }\n    }\n  }\n\n  _onFocus() {\n    if (!this.disabled) {\n      this._focused = true;\n      this.stateChanges.next();\n    }\n  }\n\n  /**\n   * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n   * \"blur\" to the panel when it opens, causing a false positive.\n   */\n  _onBlur() {\n    this._focused = false;\n    this._keyManager?.cancelTypeahead();\n\n    if (!this.disabled && !this.panelOpen) {\n      this._onTouched();\n      this._changeDetectorRef.markForCheck();\n      this.stateChanges.next();\n    }\n  }\n\n  /**\n   * Callback that is invoked when the overlay panel has been attached.\n   */\n  _onAttached(): void {\n    this._overlayDir.positionChange.pipe(take(1)).subscribe(() => {\n      this._changeDetectorRef.detectChanges();\n      this._positioningSettled();\n    });\n  }\n\n  /** Returns the theme to be used on the panel. */\n  _getPanelTheme(): string {\n    return this._parentFormField ? `mat-${this._parentFormField.color}` : '';\n  }\n\n  /** Whether the select has a value. */\n  get empty(): boolean {\n    return !this._selectionModel || this._selectionModel.isEmpty();\n  }\n\n  private _initializeSelection(): void {\n    // Defer setting the value in order to avoid the \"Expression\n    // has changed after it was checked\" errors from Angular.\n    Promise.resolve().then(() => {\n      if (this.ngControl) {\n        this._value = this.ngControl.value;\n      }\n\n      this._setSelectionByValue(this._value);\n      this.stateChanges.next();\n    });\n  }\n\n  /**\n   * Sets the selected option based on a value. If no option can be\n   * found with the designated value, the select trigger is cleared.\n   */\n  private _setSelectionByValue(value: any | any[]): void {\n    this.options.forEach(option => option.setInactiveStyles());\n    this._selectionModel.clear();\n\n    if (this.multiple && value) {\n      if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatSelectNonArrayValueError();\n      }\n\n      value.forEach((currentValue: any) => this._selectOptionByValue(currentValue));\n      this._sortValues();\n    } else {\n      const correspondingOption = this._selectOptionByValue(value);\n\n      // Shift focus to the active item. Note that we shouldn't do this in multiple\n      // mode, because we don't know what option the user interacted with last.\n      if (correspondingOption) {\n        this._keyManager.updateActiveItem(correspondingOption);\n      } else if (!this.panelOpen) {\n        // Otherwise reset the highlighted option. Note that we only want to do this while\n        // closed, because doing it while open can shift the user's focus unnecessarily.\n        this._keyManager.updateActiveItem(-1);\n      }\n    }\n\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Finds and selects and option based on its value.\n   * @returns Option that has the corresponding value.\n   */\n  private _selectOptionByValue(value: any): MatOption | undefined {\n    const correspondingOption = this.options.find((option: MatOption) => {\n      // Skip options that are already in the model. This allows us to handle cases\n      // where the same primitive value is selected multiple times.\n      if (this._selectionModel.isSelected(option)) {\n        return false;\n      }\n\n      try {\n        // Treat null as a special reset value.\n        return option.value != null && this._compareWith(option.value, value);\n      } catch (error) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          // Notify developers of errors in their comparator.\n          console.warn(error);\n        }\n        return false;\n      }\n    });\n\n    if (correspondingOption) {\n      this._selectionModel.select(correspondingOption);\n    }\n\n    return correspondingOption;\n  }\n\n  /** Assigns a specific value to the select. Returns whether the value has changed. */\n  private _assignValue(newValue: any | any[]): boolean {\n    // Always re-assign an array, because it might have been mutated.\n    if (newValue !== this._value || (this._multiple && Array.isArray(newValue))) {\n      if (this.options) {\n        this._setSelectionByValue(newValue);\n      }\n\n      this._value = newValue;\n      return true;\n    }\n    return false;\n  }\n\n  // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n  // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n  // recommendation.\n  //\n  // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n  // makes a few exceptions for compound widgets.\n  //\n  // From [Developing a Keyboard Interface](\n  // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n  //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n  //   Listbox...\"\n  //\n  // The user can focus disabled options using the keyboard, but the user cannot click disabled\n  // options.\n  private _skipPredicate = (option: MatOption) => {\n    if (this.panelOpen) {\n      // Support keyboard focusing disabled options in an ARIA listbox.\n      return false;\n    }\n\n    // When the panel is closed, skip over disabled options. Support options via the UP/DOWN arrow\n    // keys on a closed select. ARIA listbox interaction pattern is less relevant when the panel is\n    // closed.\n    return option.disabled;\n  };\n\n  /** Gets how wide the overlay panel should be. */\n  private _getOverlayWidth(\n    preferredOrigin: ElementRef<ElementRef> | CdkOverlayOrigin | undefined,\n  ): string | number {\n    if (this.panelWidth === 'auto') {\n      const refToMeasure =\n        preferredOrigin instanceof CdkOverlayOrigin\n          ? preferredOrigin.elementRef\n          : preferredOrigin || this._elementRef;\n      return refToMeasure.nativeElement.getBoundingClientRect().width;\n    }\n\n    return this.panelWidth === null ? '' : this.panelWidth;\n  }\n  /** Syncs the parent state with the individual options. */\n  _syncParentProperties(): void {\n    if (this.options) {\n      for (const option of this.options) {\n        option._changeDetectorRef.markForCheck();\n      }\n    }\n  }\n\n  /** Sets up a key manager to listen to keyboard events on the overlay panel. */\n  private _initKeyManager() {\n    this._keyManager = new ActiveDescendantKeyManager<MatOption>(this.options)\n      .withTypeAhead(this._typeaheadDebounceInterval)\n      .withVerticalOrientation()\n      .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')\n      .withHomeAndEnd()\n      .withPageUpDown()\n      .withAllowedModifierKeys(['shiftKey'])\n      .skipPredicate(this._skipPredicate);\n\n    this._keyManager.tabOut.subscribe(() => {\n      if (this.panelOpen) {\n        // Select the active item when tabbing away. This is consistent with how the native\n        // select behaves. Note that we only want to do this in single selection mode.\n        if (!this.multiple && this._keyManager.activeItem) {\n          this._keyManager.activeItem._selectViaInteraction();\n        }\n\n        // Restore focus to the trigger before closing. Ensures that the focus\n        // position won't be lost if the user got focus into the overlay.\n        this.focus();\n        this.close();\n      }\n    });\n\n    this._keyManager.change.subscribe(() => {\n      if (this._panelOpen && this.panel) {\n        this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n      } else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {\n        this._keyManager.activeItem._selectViaInteraction();\n      }\n    });\n  }\n\n  /** Drops current option subscriptions and IDs and resets from scratch. */\n  private _resetOptions(): void {\n    const changedOrDestroyed = merge(this.options.changes, this._destroy);\n\n    this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe(event => {\n      this._onSelect(event.source, event.isUserInput);\n\n      if (event.isUserInput && !this.multiple && this._panelOpen) {\n        this.close();\n        this.focus();\n      }\n    });\n\n    // Listen to changes in the internal state of the options and react accordingly.\n    // Handles cases like the labels of the selected options changing.\n    merge(...this.options.map(option => option._stateChanges))\n      .pipe(takeUntil(changedOrDestroyed))\n      .subscribe(() => {\n        // `_stateChanges` can fire as a result of a change in the label's DOM value which may\n        // be the result of an expression changing. We have to use `detectChanges` in order\n        // to avoid \"changed after checked\" errors (see #14793).\n        this._changeDetectorRef.detectChanges();\n        this.stateChanges.next();\n      });\n  }\n\n  /** Invoked when an option is clicked. */\n  private _onSelect(option: MatOption, isUserInput: boolean): void {\n    const wasSelected = this._selectionModel.isSelected(option);\n\n    if (option.value == null && !this._multiple) {\n      option.deselect();\n      this._selectionModel.clear();\n\n      if (this.value != null) {\n        this._propagateChanges(option.value);\n      }\n    } else {\n      if (wasSelected !== option.selected) {\n        option.selected\n          ? this._selectionModel.select(option)\n          : this._selectionModel.deselect(option);\n      }\n\n      if (isUserInput) {\n        this._keyManager.setActiveItem(option);\n      }\n\n      if (this.multiple) {\n        this._sortValues();\n\n        if (isUserInput) {\n          // In case the user selected the option with their mouse, we\n          // want to restore focus back to the trigger, in order to\n          // prevent the select keyboard controls from clashing with\n          // the ones from `mat-option`.\n          this.focus();\n        }\n      }\n    }\n\n    if (wasSelected !== this._selectionModel.isSelected(option)) {\n      this._propagateChanges();\n    }\n\n    this.stateChanges.next();\n  }\n\n  /** Sorts the selected values in the selected based on their order in the panel. */\n  private _sortValues() {\n    if (this.multiple) {\n      const options = this.options.toArray();\n\n      this._selectionModel.sort((a, b) => {\n        return this.sortComparator\n          ? this.sortComparator(a, b, options)\n          : options.indexOf(a) - options.indexOf(b);\n      });\n      this.stateChanges.next();\n    }\n  }\n\n  /** Emits change event to set the model value. */\n  private _propagateChanges(fallbackValue?: any): void {\n    let valueToEmit: any;\n\n    if (this.multiple) {\n      valueToEmit = (this.selected as MatOption[]).map(option => option.value);\n    } else {\n      valueToEmit = this.selected ? (this.selected as MatOption).value : fallbackValue;\n    }\n\n    this._value = valueToEmit;\n    this.valueChange.emit(valueToEmit);\n    this._onChange(valueToEmit);\n    this.selectionChange.emit(this._getChangeEvent(valueToEmit));\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Highlights the selected item. If no option is selected, it will highlight\n   * the first *enabled* option.\n   */\n  private _highlightCorrectOption(): void {\n    if (this._keyManager) {\n      if (this.empty) {\n        // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n        // because it activates the first option that passes the skip predicate, rather than the\n        // first *enabled* option.\n        let firstEnabledOptionIndex = -1;\n        for (let index = 0; index < this.options.length; index++) {\n          const option = this.options.get(index)!;\n          if (!option.disabled) {\n            firstEnabledOptionIndex = index;\n            break;\n          }\n        }\n\n        this._keyManager.setActiveItem(firstEnabledOptionIndex);\n      } else {\n        this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n      }\n    }\n  }\n\n  /** Whether the panel is allowed to open. */\n  protected _canOpen(): boolean {\n    return !this._panelOpen && !this.disabled && this.options?.length > 0;\n  }\n\n  /** Focuses the select element. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Gets the aria-labelledby for the select panel. */\n  _getPanelAriaLabelledby(): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelId = this._parentFormField?.getLabelId();\n    const labelExpression = labelId ? labelId + ' ' : '';\n    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n  }\n\n  /** Determines the `aria-activedescendant` to be set on the host. */\n  _getAriaActiveDescendant(): string | null {\n    if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {\n      return this._keyManager.activeItem.id;\n    }\n\n    return null;\n  }\n\n  /** Gets the aria-labelledby of the select component trigger. */\n  private _getTriggerAriaLabelledby(): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelId = this._parentFormField?.getLabelId();\n    let value = (labelId ? labelId + ' ' : '') + this._valueId;\n\n    if (this.ariaLabelledby) {\n      value += ' ' + this.ariaLabelledby;\n    }\n\n    return value;\n  }\n\n  /** Called when the overlay panel is done animating. */\n  protected _panelDoneAnimating(isOpen: boolean) {\n    this.openedChange.emit(isOpen);\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    this.focus();\n    this.open();\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    // Since the panel doesn't overlap the trigger, we\n    // want the label to only float when there's a value.\n    return this.panelOpen || !this.empty || (this.focused && !!this.placeholder);\n  }\n}\n\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n */\n@Directive({\n  selector: 'mat-select-trigger',\n  providers: [{provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger}],\n})\nexport class MatSelectTrigger {}\n", "<div cdk-overlay-origin\n     class=\"mat-mdc-select-trigger\"\n     (click)=\"toggle()\"\n     #fallbackOverlayOrigin=\"cdkOverlayOrigin\"\n     #trigger>\n\n  <div class=\"mat-mdc-select-value\" [attr.id]=\"_valueId\">\n    @if (empty) {\n      <span class=\"mat-mdc-select-placeholder mat-mdc-select-min-line\">{{placeholder}}</span>\n    } @else {\n      <span class=\"mat-mdc-select-value-text\">\n        @if (customTrigger) {\n          <ng-content select=\"mat-select-trigger\"></ng-content>\n        } @else {\n          <span class=\"mat-mdc-select-min-line\">{{triggerValue}}</span>\n        }\n      </span>\n    }\n  </div>\n\n  <div class=\"mat-mdc-select-arrow-wrapper\">\n    <div class=\"mat-mdc-select-arrow\">\n      <!-- Use an inline SVG, because it works better than a CSS triangle in high contrast mode. -->\n      <svg viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" focusable=\"false\" aria-hidden=\"true\">\n        <path d=\"M7 10l5 5 5-5z\"/>\n      </svg>\n    </div>\n  </div>\n</div>\n\n<ng-template\n  cdk-connected-overlay\n  cdkConnectedOverlayLockPosition\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayPanelClass]=\"_overlayPanelClass\"\n  [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\"\n  [cdkConnectedOverlayOrigin]=\"_preferredOverlayOrigin || fallbackOverlayOrigin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayWidth]=\"_overlayWidth\"\n  (backdropClick)=\"close()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"close()\">\n  <div\n    #panel\n    role=\"listbox\"\n    tabindex=\"-1\"\n    class=\"mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open {{ _getPanelTheme() }}\"\n    [attr.id]=\"id + '-panel'\"\n    [attr.aria-multiselectable]=\"multiple\"\n    [attr.aria-label]=\"ariaLabel || null\"\n    [attr.aria-labelledby]=\"_getPanelAriaLabelledby()\"\n    [ngClass]=\"panelClass\"\n    [@transformPanel]=\"'showing'\"\n    (@transformPanel.done)=\"_panelDoneAnimatingStream.next($event.toState)\"\n    (keydown)=\"_handleKeydown($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatOptionModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MatSelect, MatSelectTrigger, MAT_SELECT_SCROLL_STRATEGY_PROVIDER} from './select';\n\n@NgModule({\n  imports: [CommonModule, OverlayModule, MatOptionModule, MatCommonModule],\n  exports: [\n    CdkScrollableModule,\n    MatFormFieldModule,\n    MatSelect,\n    MatSelectTrigger,\n    MatOptionModule,\n    MatCommonModule,\n  ],\n  declarations: [MatSelect, MatSelectTrigger],\n  providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER],\n})\nexport class MatSelectModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["_c0", "_c1", "MatSelect_Conditional_4_Template", "rf", "ctx", "i0", "ɵɵelementStart", "ɵɵtext", "ɵɵelementEnd", "ctx_r2", "ɵɵnextContext", "ɵɵadvance", "ɵɵtextInterpolate", "placeholder", "MatSelect_Conditional_5_Conditional_1_Template", "ɵɵprojection", "MatSelect_Conditional_5_Conditional_2_Template", "ctx_r6", "triggerValue", "MatSelect_Conditional_5_Template", "ɵɵtemplate", "ctx_r3", "ɵɵconditional", "customTrigger", "MatSelect_ng_template_10_Template", "_r9", "ɵɵgetCurrentView", "ɵɵnamespaceSVG", "ɵɵnamespaceHTML", "ɵɵlistener", "MatSelect_ng_template_10_Template_div_animation_transformPanel_done_0_listener", "$event", "ɵɵrestoreView", "ctx_r8", "ɵɵresetView", "_panelDoneAnimatingStream", "next", "toState", "MatSelect_ng_template_10_Template_div_keydown_0_listener", "ctx_r10", "_handleKeydown", "ctx_r4", "ɵɵclassMapInterpolate1", "_getPanelTheme", "ɵɵproperty", "panelClass", "ɵɵattribute", "id", "multiple", "ariaLabel", "_getPanelAriaLabelledby", "_c2", "_c3", "matSelectAnimations", "transformPanelWrap", "trigger", "transition", "query", "animateChild", "optional", "transformPanel", "state", "style", "opacity", "transform", "animate", "getMatSelectDynamicMultipleError", "Error", "getMatSelectNonArrayValueError", "getMatSelectNonFunctionValueError", "nextUniqueId", "MAT_SELECT_SCROLL_STRATEGY", "InjectionToken", "MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY", "overlay", "scrollStrategies", "reposition", "MAT_SELECT_CONFIG", "MAT_SELECT_SCROLL_STRATEGY_PROVIDER", "provide", "deps", "Overlay", "useFactory", "MAT_SELECT_TRIGGER", "MatSelectChange", "constructor", "source", "value", "_MatSelectMixinBase", "mixinDisableRipple", "mixinTabIndex", "mixinDisabled", "mixinErrorState", "_elementRef", "_defaultErrorStateMatcher", "_parentForm", "_parentFormGroup", "ngControl", "stateChanges", "Subject", "MatSelect", "_scrollOptionIntoView", "index", "option", "options", "toArray", "panel", "nativeElement", "labelCount", "_countGroupLabelsBeforeOption", "optionGroups", "element", "_getHostElement", "scrollTop", "_getOptionScrollPosition", "offsetTop", "offsetHeight", "_positioningSettled", "_keyManager", "activeItemIndex", "_getChangeEvent", "focused", "_focused", "_panelOpen", "hideSingleSelectionIndicator", "_hideSingleSelectionIndicator", "coerceBooleanProperty", "_syncParentProperties", "_placeholder", "required", "_required", "control", "hasValidator", "Validators", "_multiple", "_selectionModel", "ngDevMode", "disableOptionCentering", "_disableOptionCentering", "compareWith", "_compareWith", "fn", "_initializeSelection", "_value", "newValue", "hasAssigned", "_assignValue", "_onChange", "typeaheadDebounceInterval", "_typeaheadDebounceInterval", "coerceNumberProperty", "_id", "_uid", "_viewportRuler", "_changeDetectorRef", "_ngZone", "elementRef", "_dir", "_parentFormField", "tabIndex", "scrollStrategyFactory", "_liveAnnouncer", "_defaultOptions", "_positions", "originX", "originY", "overlayX", "overlayY", "o1", "o2", "_triggerAriaLabelledBy", "_destroy", "_onTouched", "_valueId", "_overlayPanelClass", "overlayPanelClass", "controlType", "panelWidth", "optionSelectionChanges", "defer", "changes", "pipe", "startWith", "switchMap", "merge", "map", "onSelectionChange", "onStable", "take", "openedChange", "EventEmitter", "_openedStream", "filter", "o", "_closedStream", "selectionChange", "valueChange", "_trackedModal", "_skipPredicate", "panelOpen", "disabled", "valueAccessor", "_scrollStrategyFactory", "_scrollStrategy", "parseInt", "ngOnInit", "SelectionModel", "distinctUntilChanged", "takeUntil", "subscribe", "_panelDoneAnimating", "change", "_overlayWidth", "_getOverlayWidth", "_preferredOverlayOrigin", "detectChanges", "ngAfterContentInit", "_initKeyManager", "changed", "event", "added", "forEach", "select", "removed", "deselect", "_resetOptions", "ngDoCheck", "newAriaLabelledby", "_getTriggerAriaLabelledby", "setAttribute", "removeAttribute", "_previousControl", "undefined", "updateErrorState", "ngOnChanges", "withTypeAhead", "ngOnDestroy", "destroy", "complete", "_clearFromModal", "toggle", "close", "open", "getConnectedOverlayOrigin", "_canOpen", "_applyModalPanelOwnership", "withHorizontalOrientation", "_highlightCorrectOption", "markForCheck", "modal", "closest", "panelId", "removeAriaReferencedId", "addAriaReferencedId", "_isRtl", "writeValue", "registerOnChange", "registerOnTouched", "setDisabledState", "isDisabled", "selected", "empty", "selectedOptions", "viewValue", "reverse", "join", "_handleOpenKeydown", "_handleClosedKeydown", "keyCode", "isArrowKey", "DOWN_ARROW", "UP_ARROW", "LEFT_ARROW", "RIGHT_ARROW", "isOpenKey", "ENTER", "SPACE", "manager", "isTyping", "hasModifierKey", "altKey", "preventDefault", "previouslySelectedOption", "onKeydown", "selectedOption", "announce", "activeItem", "_selectViaInteraction", "A", "ctrlKey", "hasDeselectedOptions", "some", "opt", "previouslyFocusedIndex", "shiftKey", "_onFocus", "_onBlur", "cancelTypeahead", "_onAttached", "_overlayDir", "positionChange", "color", "isEmpty", "Promise", "resolve", "then", "_setSelectionByValue", "setInactiveStyles", "clear", "Array", "isArray", "currentValue", "_selectOptionByValue", "_sortValues", "correspondingOption", "updateActiveItem", "find", "isSelected", "error", "console", "warn", "preferredOrigin", "refToMeasure", "CdkOverlayOrigin", "getBoundingClientRect", "width", "ActiveDescendantKeyManager", "withVerticalOrientation", "withHomeAndEnd", "withPageUpDown", "withAllowedModifierKeys", "skipPredicate", "tabOut", "focus", "changedOrDestroyed", "_onSelect", "isUserInput", "_stateChanges", "wasSelected", "_propagateChanges", "setActiveItem", "sort", "a", "b", "sortComparator", "indexOf", "fallbackValue", "valueToEmit", "emit", "firstEnabledOptionIndex", "length", "get", "labelId", "getLabelId", "labelExpression", "ariaLabelledby", "_getAriaActiveDescendant", "isOpen", "setDescribedByIds", "ids", "onContainerClick", "shouldLabelFloat", "ɵfac", "MatSelect_Factory", "t", "ɵɵdirectiveInject", "ViewportRuler", "ChangeDetectorRef", "NgZone", "ErrorStateMatcher", "ElementRef", "Directionality", "NgForm", "FormGroupDirective", "MAT_FORM_FIELD", "NgControl", "ɵɵinjectAttribute", "LiveAnnouncer", "ɵcmp", "ɵɵdefineComponent", "type", "selectors", "contentQueries", "MatSelect_ContentQueries", "dirIndex", "ɵɵcontentQuery", "MatOption", "MAT_OPTGROUP", "_t", "ɵɵqueryRefresh", "ɵɵloadQuery", "first", "viewQuery", "MatSelect_Query", "ɵɵviewQuery", "CdkConnectedOverlay", "hostAttrs", "hostVars", "hostBindings", "MatSelect_HostBindings", "MatSelect_keydown_HostBindingHandler", "MatSelect_focus_HostBindingHandler", "MatSelect_blur_HostBindingHandler", "toString", "errorState", "ɵɵclassProp", "inputs", "disableRipple", "userAriaDescribedBy", "errorStateMatcher", "outputs", "exportAs", "features", "ɵɵProvidersFeature", "MatFormFieldControl", "useExisting", "MAT_OPTION_PARENT_COMPONENT", "ɵɵInheritDefinitionFeature", "ɵɵNgOnChangesFeature", "ngContentSelectors", "decls", "vars", "consts", "template", "MatSelect_Template", "ɵɵprojectionDef", "MatSelect_Template_div_click_0_listener", "ɵɵelement", "MatSelect_Template_ng_template_backdropClick_10_listener", "MatSelect_Template_ng_template_attach_10_listener", "MatSelect_Template_ng_template_detach_10_listener", "_r0", "ɵɵreference", "dependencies", "NgClass", "styles", "encapsulation", "data", "animation", "changeDetection", "ɵsetClassMetadata", "Component", "args", "selector", "ViewEncapsulation", "None", "ChangeDetectionStrategy", "OnPush", "host", "animations", "providers", "Optional", "Inject", "Self", "Attribute", "ContentChildren", "descendants", "ContentChild", "Input", "ViewChild", "Output", "MatSelectTrigger", "ɵɵdefineDirective", "Directive", "MatSelectModule", "ɵmod", "ɵɵdefineNgModule", "declarations", "imports", "CommonModule", "OverlayModule", "MatOptionModule", "MatCommonModule", "exports", "CdkScrollableModule", "MatFormFieldModule", "ɵinj", "ɵɵdefineInjector", "NgModule"]
}
