{
  "version": 3,
  "sources": ["../../../../../../../src/material/radio/radio.ts", "../../../../../../../src/material/radio/radio.html", "../../../../../../../src/material/radio/module.ts", "../../../../../../../src/material/radio/radio_public_index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  CanDisableRipple,\n  HasTabIndex,\n  mixinDisableRipple,\n  mixinTabIndex,\n  ThemePalette,\n} from '@angular/material/core';\nimport {FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {BooleanInput, coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {UniqueSelectionDispatcher} from '@angular/cdk/collections';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {Subscription} from 'rxjs';\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n\n/** Change event object emitted by radio button and radio group. */\nexport class MatRadioChange {\n  constructor(\n    /** The radio button that emits the change event. */\n    public source: MatRadioButton,\n    /** The value of the radio button. */\n    public value: any,\n  ) {}\n}\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true,\n};\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_RADIO_GROUP = new InjectionToken<MatRadioGroup>('MatRadioGroup');\n\nexport interface MatRadioDefaultOptions {\n  color: ThemePalette;\n}\n\nexport const MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken<MatRadioDefaultOptions>(\n  'mat-radio-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\nexport function MAT_RADIO_DEFAULT_OPTIONS_FACTORY(): MatRadioDefaultOptions {\n  return {\n    color: 'accent',\n  };\n}\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\n@Directive({\n  selector: 'mat-radio-group',\n  exportAs: 'matRadioGroup',\n  providers: [\n    MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n    {provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup},\n  ],\n  host: {\n    'role': 'radiogroup',\n    'class': 'mat-mdc-radio-group',\n  },\n})\nexport class MatRadioGroup implements AfterContentInit, OnDestroy, ControlValueAccessor {\n  /** Selected value for the radio group. */\n  private _value: any = null;\n\n  /** The HTML name attribute applied to radio buttons in this group. */\n  private _name: string = `mat-radio-group-${nextUniqueId++}`;\n\n  /** The currently selected radio button. Should match value. */\n  private _selected: MatRadioButton | null = null;\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  private _labelPosition: 'before' | 'after' = 'after';\n\n  /** Whether the radio group is disabled. */\n  private _disabled: boolean = false;\n\n  /** Whether the radio group is required. */\n  private _required: boolean = false;\n\n  /** Subscription to changes in amount of radio buttons. */\n  private _buttonChanges: Subscription;\n\n  /** The method to be called in order to update ngModel */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /**\n   * onTouch function registered via registerOnTouch (ControlValueAccessor).\n   * @docs-private\n   */\n  onTouched: () => any = () => {};\n\n  /**\n   * Event emitted when the group value changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * a radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** Child radio buttons. */\n  @ContentChildren(forwardRef(() => MatRadioButton), {descendants: true})\n  _radios: QueryList<MatRadioButton>;\n\n  /** Theme color for all of the radio buttons in the group. */\n  @Input() color: ThemePalette;\n\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition;\n  }\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n\n  /**\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\n   * a corresponding radio button with a matching value. If there is not such a corresponding\n   * radio button, this value persists to be applied in case a new radio button is added with a\n   * matching value.\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n\n  /**\n   * The currently selected radio button. If set to a new radio button, the radio group value\n   * will be updated to match the new selected button.\n   */\n  @Input()\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected: MatRadioButton | null) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n\n  /** Whether the radio group is disabled */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  /** Whether the radio group is required */\n  @Input()\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  constructor(private _changeDetector: ChangeDetectorRef) {}\n\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n\n    // Clear the `selected` button when it's destroyed since the tabindex of the rest of the\n    // buttons depends on it. Note that we don't clear the `value`, because the radio button\n    // may be swapped out with a similar one and there are some internal apps that depend on\n    // that behavior.\n    this._buttonChanges = this._radios.changes.subscribe(() => {\n      if (this.selected && !this._radios.find(radio => radio === this.selected)) {\n        this._selected = null;\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._buttonChanges?.unsubscribe();\n  }\n\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  private _updateRadioButtonNames(): void {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n        radio._markForCheck();\n      });\n    }\n  }\n\n  /** Updates the `selected` radio button from the internal _value state. */\n  private _updateSelectedRadioFromValue(): void {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(): void {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected!, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnTouched(fn: any) {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param isDisabled Whether the control should be disabled.\n   */\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n// Boilerplate for applying mixins to MatRadioButton.\n/** @docs-private */\nabstract class MatRadioButtonBase {\n  // Since the disabled property is manually defined for the MatRadioButton and isn't set up in\n  // the mixin base class. To be able to use the tabindex mixin, a disabled property must be\n  // defined to properly work.\n  abstract disabled: boolean;\n  constructor(public _elementRef: ElementRef) {}\n}\n\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n\n@Component({\n  selector: 'mat-radio-button',\n  templateUrl: 'radio.html',\n  styleUrls: ['radio.css'],\n  host: {\n    'class': 'mat-mdc-radio-button',\n    '[attr.id]': 'id',\n    '[class.mat-primary]': 'color === \"primary\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    '[class.mat-mdc-radio-checked]': 'checked',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n    // Needs to be removed since it causes some a11y issues (see #21266).\n    '[attr.tabindex]': 'null',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    // Note: under normal conditions focus shouldn't land on this element, however it may be\n    // programmatically set, for example inside of a focus trap, in this case we want to forward\n    // the focus to the native element.\n    '(focus)': '_inputElement.nativeElement.focus()',\n  },\n  inputs: ['disableRipple', 'tabIndex'],\n  exportAs: 'matRadioButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatRadioButton\n  extends _MatRadioButtonMixinBase\n  implements OnInit, AfterViewInit, DoCheck, OnDestroy, CanDisableRipple, HasTabIndex\n{\n  private _uniqueId: string = `mat-radio-${++nextUniqueId}`;\n\n  /** The unique ID for the radio button. */\n  @Input() id: string = this._uniqueId;\n\n  /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** Used to set the 'aria-label' attribute on the underlying input element. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Whether this radio button is checked. */\n  @Input()\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: BooleanInput) {\n    const newCheckedState = coerceBooleanProperty(value);\n    if (this._checked !== newCheckedState) {\n      this._checked = newCheckedState;\n      if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** The value of this radio button. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._value !== value) {\n      this._value = value;\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n  }\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  private _labelPosition: 'before' | 'after';\n\n  /** Whether the radio button is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n  }\n  set disabled(value: BooleanInput) {\n    this._setDisabled(coerceBooleanProperty(value));\n  }\n\n  /** Whether the radio button is required. */\n  @Input()\n  get required(): boolean {\n    return this._required || (this.radioGroup && this.radioGroup.required);\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n\n  /** Theme color of the radio button. */\n  @Input()\n  get color(): ThemePalette {\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    return (\n      this._color ||\n      (this.radioGroup && this.radioGroup.color) ||\n      (this._providerOverride && this._providerOverride.color) ||\n      'accent'\n    );\n  }\n  set color(newValue: ThemePalette) {\n    this._color = newValue;\n  }\n  private _color: ThemePalette;\n\n  /**\n   * Event emitted when the checked state of this radio button changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * the radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** The parent radio group. May or may not be present. */\n  radioGroup: MatRadioGroup;\n\n  /** ID of the native input element inside `<mat-radio-button>` */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether this radio is checked. */\n  private _checked: boolean = false;\n\n  /** Whether this radio is disabled. */\n  private _disabled: boolean;\n\n  /** Whether this radio is required. */\n  private _required: boolean;\n\n  /** Value assigned to this radio. */\n  private _value: any = null;\n\n  /** Unregister function for _radioDispatcher */\n  private _removeUniqueSelectionListener: () => void = () => {};\n\n  /** Previous value of the input's tabindex. */\n  private _previousTabIndex: number | undefined;\n\n  /** The native `<input type=radio>` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Whether animations are disabled. */\n  _noopAnimations: boolean;\n\n  constructor(\n    @Optional() @Inject(MAT_RADIO_GROUP) radioGroup: MatRadioGroup,\n    elementRef: ElementRef,\n    private _changeDetector: ChangeDetectorRef,\n    private _focusMonitor: FocusMonitor,\n    private _radioDispatcher: UniqueSelectionDispatcher,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional()\n    @Inject(MAT_RADIO_DEFAULT_OPTIONS)\n    private _providerOverride?: MatRadioDefaultOptions,\n    @Attribute('tabindex') tabIndex?: string,\n  ) {\n    super(elementRef);\n\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._noopAnimations = animationMode === 'NoopAnimations';\n\n    if (tabIndex) {\n      this.tabIndex = coerceNumberProperty(tabIndex, 0);\n    }\n  }\n\n  /** Focuses the radio button. */\n  focus(options?: FocusOptions, origin?: FocusOrigin): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      }\n\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n\n    this._removeUniqueSelectionListener = this._radioDispatcher.listen((id, name) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n\n  ngDoCheck(): void {\n    this._updateTabIndex();\n  }\n\n  ngAfterViewInit() {\n    this._updateTabIndex();\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._removeUniqueSelectionListener();\n  }\n\n  /** Dispatch change event with current value. */\n  private _emitChangeEvent(): void {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n\n  /** Triggered when the radio button receives an interaction from the user. */\n  _onInputInteraction(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n\n  /** Triggered when the user clicks on the touch target. */\n  _onTouchTargetClick(event: Event) {\n    this._onInputInteraction(event);\n\n    if (!this.disabled) {\n      // Normally the input should be focused already, but if the click\n      // comes from the touch target, then we might have to focus it ourselves.\n      this._inputElement.nativeElement.focus();\n    }\n  }\n\n  /** Sets the disabled state and marks for check if a change occurred. */\n  protected _setDisabled(value: boolean) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** Gets the tabindex for the underlying input element. */\n  private _updateTabIndex() {\n    const group = this.radioGroup;\n    let value: number;\n\n    // Implement a roving tabindex if the button is inside a group. For most cases this isn't\n    // necessary, because the browser handles the tab order for inputs inside a group automatically,\n    // but we need an explicitly higher tabindex for the selected button in order for things like\n    // the focus trap to pick it up correctly.\n    if (!group || !group.selected || this.disabled) {\n      value = this.tabIndex;\n    } else {\n      value = group.selected === this ? this.tabIndex : -1;\n    }\n\n    if (value !== this._previousTabIndex) {\n      // We have to set the tabindex directly on the DOM node, because it depends on\n      // the selected state which is prone to \"changed after checked errors\".\n      const input: HTMLInputElement | undefined = this._inputElement?.nativeElement;\n\n      if (input) {\n        input.setAttribute('tabindex', value + '');\n        this._previousTabIndex = value;\n      }\n    }\n  }\n}\n", "<div class=\"mdc-form-field\" #formField\n     [class.mdc-form-field--align-end]=\"labelPosition == 'before'\">\n  <div class=\"mdc-radio\" [class.mdc-radio--disabled]=\"disabled\">\n    <!-- Render this element first so the input is on top. -->\n    <div class=\"mat-mdc-radio-touch-target\" (click)=\"_onTouchTargetClick($event)\"></div>\n    <input #input class=\"mdc-radio__native-control\" type=\"radio\"\n           [id]=\"inputId\"\n           [checked]=\"checked\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [attr.value]=\"value\"\n           [required]=\"required\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-describedby]=\"ariaDescribedby\"\n           (change)=\"_onInputInteraction($event)\">\n    <div class=\"mdc-radio__background\">\n      <div class=\"mdc-radio__outer-circle\"></div>\n      <div class=\"mdc-radio__inner-circle\"></div>\n    </div>\n    <div mat-ripple class=\"mat-radio-ripple mat-mdc-focus-indicator\"\n         [matRippleTrigger]=\"formField\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleCentered]=\"true\">\n      <div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div>\n    </div>\n  </div>\n  <label class=\"mdc-label\" [for]=\"inputId\">\n    <ng-content></ng-content>\n  </label>\n</div>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatRadioButton, MatRadioGroup} from './radio';\n\n@NgModule({\n  imports: [MatCommonModule, CommonModule, MatRippleModule],\n  exports: [MatCommonModule, MatRadioGroup, MatRadioButton],\n  declarations: [MatRadioGroup, MatRadioButton],\n})\nexport class MatRadioModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["_c0", "_c1", "nextUniqueId", "MatRadioChange", "constructor", "source", "value", "MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR", "provide", "NG_VALUE_ACCESSOR", "useExisting", "forwardRef", "MatRadioGroup", "multi", "MAT_RADIO_GROUP", "InjectionToken", "MAT_RADIO_DEFAULT_OPTIONS", "providedIn", "factory", "MAT_RADIO_DEFAULT_OPTIONS_FACTORY", "color", "name", "_name", "_updateRadioButtonNames", "labelPosition", "_labelPosition", "v", "_markRadiosForCheck", "_value", "newValue", "_updateSelectedRadioFromValue", "_checkSelectedRadioButton", "_selected", "checked", "selected", "disabled", "_disabled", "coerceBooleanProperty", "required", "_required", "_changeDetector", "_isInitialized", "_controlValueAccessorChangeFn", "onTouched", "change", "EventEmitter", "ngAfterContentInit", "_buttonChanges", "_radios", "changes", "subscribe", "find", "radio", "ngOnDestroy", "unsubscribe", "_touch", "forEach", "_markForCheck", "isAlreadySelected", "_emitChangeEvent", "emit", "writeValue", "markForCheck", "registerOnChange", "fn", "registerOnTouched", "setDisabledState", "isDisabled", "ChangeDetectorRef", "ɵdir", "selectors", "contentQueries", "MatRadioGroup_ContentQueries", "rf", "ctx", "dirIndex", "MatRadioButton", "_t", "inputs", "outputs", "exportAs", "features", "Directive", "args", "selector", "providers", "host", "Output", "ContentChildren", "descendants", "Input", "MatRadioButtonBase", "_elementRef", "_MatRadioButtonMixinBase", "mixinDisableRipple", "mixinTabIndex", "_checked", "newCheckedState", "radioGroup", "_radioDispatcher", "notify", "id", "_setDisabled", "_color", "_providerOverride", "inputId", "_uniqueId", "elementRef", "_focusMonitor", "animationMode", "tabIndex", "_removeUniqueSelectionListener", "_noopAnimations", "coerceNumberProperty", "focus", "options", "origin", "focusVia", "_inputElement", "nativeElement", "ngOnInit", "listen", "ngDoCheck", "_updateTabIndex", "ngAfterViewInit", "monitor", "focusOrigin", "stopMonitoring", "_isRippleDisabled", "disableRipple", "_onInputClick", "event", "stopPropagation", "_onInputInteraction", "groupValueChanged", "_onTouchTargetClick", "group", "_previousTabIndex", "input", "setAttribute", "ɵfac", "MatRadioButton_Factory", "t", "ElementRef", "FocusMonitor", "UniqueSelectionDispatcher", "ANIMATION_MODULE_TYPE", "ɵcmp", "viewQuery", "MatRadioButton_Query", "$event", "_r0", "ariaLabel", "ariaLabelledby", "ariaDescribedby", "dependencies", "MatRipple", "styles", "encapsulation", "changeDetection", "Component", "ViewEncapsulation", "None", "ChangeDetectionStrategy", "OnPush", "template", "Optional", "Inject", "Attribute", "ViewChild", "MatRadioModule", "ɵmod", "declarations", "imports", "MatCommonModule", "CommonModule", "MatRippleModule", "exports", "ɵinj", "NgModule"]
}
